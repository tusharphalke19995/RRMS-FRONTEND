{"ast":null,"code":"import { map, ReplaySubject, switchMap, take, tap } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class NotificationsService {\n  /**\n   * Constructor\n   */\n  constructor(_httpClient) {\n    this._httpClient = _httpClient;\n    this._notifications = new ReplaySubject(1);\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Getter for notifications\n   */\n  get notifications$() {\n    return this._notifications.asObservable();\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Get all notifications\n   */\n  getAll() {\n    return this._httpClient.get('api/common/notifications').pipe(tap(notifications => {\n      this._notifications.next(notifications);\n    }));\n  }\n  /**\n   * Create a notification\n   *\n   * @param notification\n   */\n  create(notification) {\n    return this.notifications$.pipe(take(1), switchMap(notifications => this._httpClient.post('api/common/notifications', {\n      notification\n    }).pipe(map(newNotification => {\n      // Update the notifications with the new notification\n      this._notifications.next([...notifications, newNotification]);\n      // Return the new notification from observable\n      return newNotification;\n    }))));\n  }\n  /**\n   * Update the notification\n   *\n   * @param id\n   * @param notification\n   */\n  update(id, notification) {\n    return this.notifications$.pipe(take(1), switchMap(notifications => this._httpClient.patch('api/common/notifications', {\n      id,\n      notification\n    }).pipe(map(updatedNotification => {\n      // Find the index of the updated notification\n      const index = notifications.findIndex(item => item.id === id);\n      // Update the notification\n      notifications[index] = updatedNotification;\n      // Update the notifications\n      this._notifications.next(notifications);\n      // Return the updated notification\n      return updatedNotification;\n    }))));\n  }\n  /**\n   * Delete the notification\n   *\n   * @param id\n   */\n  delete(id) {\n    return this.notifications$.pipe(take(1), switchMap(notifications => this._httpClient.delete('api/common/notifications', {\n      params: {\n        id\n      }\n    }).pipe(map(isDeleted => {\n      // Find the index of the deleted notification\n      const index = notifications.findIndex(item => item.id === id);\n      // Delete the notification\n      notifications.splice(index, 1);\n      // Update the notifications\n      this._notifications.next(notifications);\n      // Return the deleted status\n      return isDeleted;\n    }))));\n  }\n  /**\n   * Mark all notifications as read\n   */\n  markAllAsRead() {\n    return this.notifications$.pipe(take(1), switchMap(notifications => this._httpClient.get('api/common/notifications/mark-all-as-read').pipe(map(isUpdated => {\n      // Go through all notifications and set them as read\n      notifications.forEach((notification, index) => {\n        notifications[index].read = true;\n      });\n      // Update the notifications\n      this._notifications.next(notifications);\n      // Return the updated status\n      return isUpdated;\n    }))));\n  }\n  static #_ = this.ɵfac = function NotificationsService_Factory(t) {\n    return new (t || NotificationsService)(i0.ɵɵinject(i1.HttpClient));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: NotificationsService,\n    factory: NotificationsService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["map","ReplaySubject","switchMap","take","tap","NotificationsService","constructor","_httpClient","_notifications","notifications$","asObservable","getAll","get","pipe","notifications","next","create","notification","post","newNotification","update","id","patch","updatedNotification","index","findIndex","item","delete","params","isDeleted","splice","markAllAsRead","isUpdated","forEach","read","_","i0","ɵɵinject","i1","HttpClient","_2","factory","ɵfac","providedIn"],"sources":["/Users/tusharphalke/Documents/Freelancing_Work/rrms_frontend/src/app/layout/common/notifications/notifications.service.ts"],"sourcesContent":["import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Notification } from 'app/layout/common/notifications/notifications.types';\nimport { map, Observable, ReplaySubject, switchMap, take, tap } from 'rxjs';\n\n@Injectable({providedIn: 'root'})\nexport class NotificationsService\n{\n    private _notifications: ReplaySubject<Notification[]> = new ReplaySubject<Notification[]>(1);\n\n    /**\n     * Constructor\n     */\n    constructor(private _httpClient: HttpClient)\n    {\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Accessors\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Getter for notifications\n     */\n    get notifications$(): Observable<Notification[]>\n    {\n        return this._notifications.asObservable();\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Public methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Get all notifications\n     */\n    getAll(): Observable<Notification[]>\n    {\n        return this._httpClient.get<Notification[]>('api/common/notifications').pipe(\n            tap((notifications) =>\n            {\n                this._notifications.next(notifications);\n            }),\n        );\n    }\n\n    /**\n     * Create a notification\n     *\n     * @param notification\n     */\n    create(notification: Notification): Observable<Notification>\n    {\n        return this.notifications$.pipe(\n            take(1),\n            switchMap(notifications => this._httpClient.post<Notification>('api/common/notifications', {notification}).pipe(\n                map((newNotification) =>\n                {\n                    // Update the notifications with the new notification\n                    this._notifications.next([...notifications, newNotification]);\n\n                    // Return the new notification from observable\n                    return newNotification;\n                }),\n            )),\n        );\n    }\n\n    /**\n     * Update the notification\n     *\n     * @param id\n     * @param notification\n     */\n    update(id: string, notification: Notification): Observable<Notification>\n    {\n        return this.notifications$.pipe(\n            take(1),\n            switchMap(notifications => this._httpClient.patch<Notification>('api/common/notifications', {\n                id,\n                notification,\n            }).pipe(\n                map((updatedNotification: Notification) =>\n                {\n                    // Find the index of the updated notification\n                    const index = notifications.findIndex(item => item.id === id);\n\n                    // Update the notification\n                    notifications[index] = updatedNotification;\n\n                    // Update the notifications\n                    this._notifications.next(notifications);\n\n                    // Return the updated notification\n                    return updatedNotification;\n                }),\n            )),\n        );\n    }\n\n    /**\n     * Delete the notification\n     *\n     * @param id\n     */\n    delete(id: string): Observable<boolean>\n    {\n        return this.notifications$.pipe(\n            take(1),\n            switchMap(notifications => this._httpClient.delete<boolean>('api/common/notifications', {params: {id}}).pipe(\n                map((isDeleted: boolean) =>\n                {\n                    // Find the index of the deleted notification\n                    const index = notifications.findIndex(item => item.id === id);\n\n                    // Delete the notification\n                    notifications.splice(index, 1);\n\n                    // Update the notifications\n                    this._notifications.next(notifications);\n\n                    // Return the deleted status\n                    return isDeleted;\n                }),\n            )),\n        );\n    }\n\n    /**\n     * Mark all notifications as read\n     */\n    markAllAsRead(): Observable<boolean>\n    {\n        return this.notifications$.pipe(\n            take(1),\n            switchMap(notifications => this._httpClient.get<boolean>('api/common/notifications/mark-all-as-read').pipe(\n                map((isUpdated: boolean) =>\n                {\n                    // Go through all notifications and set them as read\n                    notifications.forEach((notification, index) =>\n                    {\n                        notifications[index].read = true;\n                    });\n\n                    // Update the notifications\n                    this._notifications.next(notifications);\n\n                    // Return the updated status\n                    return isUpdated;\n                }),\n            )),\n        );\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}