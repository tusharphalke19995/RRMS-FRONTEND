{"ast":null,"code":"// -----------------------------------------------------------------------------------------------------\n// @ AUTH UTILITIES\n//\n// Methods are derivations of the Auth0 Angular-JWT helper service methods\n// https://github.com/auth0/angular2-jwt\n// -----------------------------------------------------------------------------------------------------\nexport class AuthUtils {\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Is token expired?\n   *\n   * @param token\n   * @param offsetSeconds\n   */\n  static isTokenExpired(token, offsetSeconds) {\n    // Return if there is no token\n    if (!token || token === '') {\n      return true;\n    }\n    // Get the expiration date\n    const date = this._getTokenExpirationDate(token);\n    offsetSeconds = offsetSeconds || 0;\n    if (date === null) {\n      return true;\n    }\n    // Check if the token is expired\n    return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Private methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Base64 decoder\n   * Credits: https://github.com/atk\n   *\n   * @param str\n   * @private\n   */\n  static _b64decode(str) {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    let output = '';\n    str = String(str).replace(/=+$/, '');\n    if (str.length % 4 === 1) {\n      throw new Error('\\'atob\\' failed: The string to be decoded is not correctly encoded.');\n    }\n    /* eslint-disable */\n    for (\n    // initialize result and counters\n    let bc = 0, bs, buffer, idx = 0;\n    // get next character\n    buffer = str.charAt(idx++);\n    // character found in table? initialize bit storage and add its ascii value;\n    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n    // and if not first of each 4 characters,\n    // convert the first 8 bits to one ascii character\n    bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    /* eslint-enable */\n    return output;\n  }\n  /**\n   * Base64 unicode decoder\n   *\n   * @param str\n   * @private\n   */\n  static _b64DecodeUnicode(str) {\n    return decodeURIComponent(Array.prototype.map.call(this._b64decode(str), c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));\n  }\n  /**\n   * URL Base 64 decoder\n   *\n   * @param str\n   * @private\n   */\n  static _urlBase64Decode(str) {\n    let output = str.replace(/-/g, '+').replace(/_/g, '/');\n    switch (output.length % 4) {\n      case 0:\n        {\n          break;\n        }\n      case 2:\n        {\n          output += '==';\n          break;\n        }\n      case 3:\n        {\n          output += '=';\n          break;\n        }\n      default:\n        {\n          throw Error('Illegal base64url string!');\n        }\n    }\n    return this._b64DecodeUnicode(output);\n  }\n  /**\n   * Decode token\n   *\n   * @param token\n   * @private\n   */\n  static _decodeToken(token) {\n    // Return if there is no token\n    if (!token) {\n      return null;\n    }\n    // Split the token\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      throw new Error('The inspected token doesn\\'t appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.');\n    }\n    // Decode the token using the Base64 decoder\n    const decoded = this._urlBase64Decode(parts[1]);\n    if (!decoded) {\n      throw new Error('Cannot decode the token.');\n    }\n    return JSON.parse(decoded);\n  }\n  /**\n   * Get token expiration date\n   *\n   * @param token\n   * @private\n   */\n  static _getTokenExpirationDate(token) {\n    // Get the decoded token\n    const decodedToken = this._decodeToken(token);\n    // Return if the decodedToken doesn't have an 'exp' field\n    if (!decodedToken.hasOwnProperty('exp')) {\n      return null;\n    }\n    // Convert the expiration date\n    const date = new Date(0);\n    date.setUTCSeconds(decodedToken.exp);\n    return date;\n  }\n}","map":{"version":3,"names":["AuthUtils","isTokenExpired","token","offsetSeconds","date","_getTokenExpirationDate","valueOf","Date","_b64decode","str","chars","output","String","replace","length","Error","bc","bs","buffer","idx","charAt","fromCharCode","indexOf","_b64DecodeUnicode","decodeURIComponent","Array","prototype","map","call","c","charCodeAt","toString","slice","join","_urlBase64Decode","_decodeToken","parts","split","decoded","JSON","parse","decodedToken","hasOwnProperty","setUTCSeconds","exp"],"sources":["/Users/tusharphalke/Documents/Freelancing_Work/rrms_frontend/src/app/core/auth/auth.utils.ts"],"sourcesContent":["// -----------------------------------------------------------------------------------------------------\n// @ AUTH UTILITIES\n//\n// Methods are derivations of the Auth0 Angular-JWT helper service methods\n// https://github.com/auth0/angular2-jwt\n// -----------------------------------------------------------------------------------------------------\n\nexport class AuthUtils\n{\n    // -----------------------------------------------------------------------------------------------------\n    // @ Public methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Is token expired?\n     *\n     * @param token\n     * @param offsetSeconds\n     */\n    static isTokenExpired(token: string, offsetSeconds?: number): boolean\n    {\n        // Return if there is no token\n        if ( !token || token === '' )\n        {\n            return true;\n        }\n\n        // Get the expiration date\n        const date = this._getTokenExpirationDate(token);\n\n        offsetSeconds = offsetSeconds || 0;\n\n        if ( date === null )\n        {\n            return true;\n        }\n\n        // Check if the token is expired\n        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Private methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Base64 decoder\n     * Credits: https://github.com/atk\n     *\n     * @param str\n     * @private\n     */\n    private static _b64decode(str: string): string\n    {\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        let output = '';\n\n        str = String(str).replace(/=+$/, '');\n\n        if ( str.length % 4 === 1 )\n        {\n            throw new Error(\n                '\\'atob\\' failed: The string to be decoded is not correctly encoded.',\n            );\n        }\n\n        /* eslint-disable */\n        for (\n            // initialize result and counters\n            let bc = 0, bs: any, buffer: any, idx = 0;\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            (\n                (bs = bc % 4 ? bs * 64 + buffer : buffer),\n                    // and if not first of each 4 characters,\n                    // convert the first 8 bits to one ascii character\n                bc++ % 4\n            )\n                ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n                : 0\n        )\n        {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n        /* eslint-enable */\n\n        return output;\n    }\n\n    /**\n     * Base64 unicode decoder\n     *\n     * @param str\n     * @private\n     */\n    private static _b64DecodeUnicode(str: any): string\n    {\n        return decodeURIComponent(\n            Array.prototype.map\n                .call(this._b64decode(str), (c: any) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n                .join(''),\n        );\n    }\n\n    /**\n     * URL Base 64 decoder\n     *\n     * @param str\n     * @private\n     */\n    private static _urlBase64Decode(str: string): string\n    {\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\n        switch ( output.length % 4 )\n        {\n            case 0:\n            {\n                break;\n            }\n            case 2:\n            {\n                output += '==';\n                break;\n            }\n            case 3:\n            {\n                output += '=';\n                break;\n            }\n            default:\n            {\n                throw Error('Illegal base64url string!');\n            }\n        }\n        return this._b64DecodeUnicode(output);\n    }\n\n    /**\n     * Decode token\n     *\n     * @param token\n     * @private\n     */\n    private static _decodeToken(token: string): any\n    {\n        // Return if there is no token\n        if ( !token )\n        {\n            return null;\n        }\n\n        // Split the token\n        const parts = token.split('.');\n\n        if ( parts.length !== 3 )\n        {\n            throw new Error('The inspected token doesn\\'t appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.');\n        }\n\n        // Decode the token using the Base64 decoder\n        const decoded = this._urlBase64Decode(parts[1]);\n\n        if ( !decoded )\n        {\n            throw new Error('Cannot decode the token.');\n        }\n\n        return JSON.parse(decoded);\n    }\n\n    /**\n     * Get token expiration date\n     *\n     * @param token\n     * @private\n     */\n    private static _getTokenExpirationDate(token: string): Date | null\n    {\n        // Get the decoded token\n        const decodedToken = this._decodeToken(token);\n\n        // Return if the decodedToken doesn't have an 'exp' field\n        if ( !decodedToken.hasOwnProperty('exp') )\n        {\n            return null;\n        }\n\n        // Convert the expiration date\n        const date = new Date(0);\n        date.setUTCSeconds(decodedToken.exp);\n\n        return date;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}