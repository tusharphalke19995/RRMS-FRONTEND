{"ast":null,"code":"import { HttpClient } from '@angular/common/http';\nimport { inject } from '@angular/core';\nimport { AuthUtils } from 'app/core/auth/auth.utils';\nimport { UserService } from 'app/core/user/user.service';\nimport { catchError, of, switchMap, throwError } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class AuthService {\n  constructor() {\n    this._authenticated = false;\n    this._httpClient = inject(HttpClient);\n    this._userService = inject(UserService);\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Setter & getter for access token\n   */\n  set accessToken(token) {\n    localStorage.setItem('accessToken', token);\n  }\n  get accessToken() {\n    return localStorage.getItem('accessToken') ?? '';\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Forgot password\n   *\n   * @param email\n   */\n  forgotPassword(email) {\n    return this._httpClient.post('api/auth/forgot-password', email);\n  }\n  /**\n   * Reset password\n   *\n   * @param password\n   */\n  resetPassword(password) {\n    return this._httpClient.post('api/auth/reset-password', password);\n  }\n  /**\n   * Sign in\n   *\n   * @param credentials\n   */\n  signIn(credentials) {\n    // Throw error, if the user is already logged in\n    if (this._authenticated) {\n      return throwError('User is already logged in.');\n    }\n    return this._httpClient.post('api/auth/sign-in', credentials).pipe(switchMap(response => {\n      // Store the access token in the local storage\n      this.accessToken = response.accessToken;\n      // Set the authenticated flag to true\n      this._authenticated = true;\n      // Store the user on the user service\n      this._userService.user = response.user;\n      // Return a new observable with the response\n      return of(response);\n    }));\n  }\n  /**\n   * Sign in using the access token\n   */\n  signInUsingToken() {\n    // Sign in using the token\n    return this._httpClient.post('api/auth/sign-in-with-token', {\n      accessToken: this.accessToken\n    }).pipe(catchError(() =>\n    // Return false\n    of(false)), switchMap(response => {\n      // Replace the access token with the new one if it's available on\n      // the response object.\n      //\n      // This is an added optional step for better security. Once you sign\n      // in using the token, you should generate a new one on the server\n      // side and attach it to the response object. Then the following\n      // piece of code can replace the token with the refreshed one.\n      if (response.accessToken) {\n        this.accessToken = response.accessToken;\n      }\n      // Set the authenticated flag to true\n      this._authenticated = true;\n      // Store the user on the user service\n      this._userService.user = response.user;\n      // Return true\n      return of(true);\n    }));\n  }\n  /**\n   * Sign out\n   */\n  signOut() {\n    // Remove the access token from the local storage\n    localStorage.removeItem('accessToken');\n    // Set the authenticated flag to false\n    this._authenticated = false;\n    // Return the observable\n    return of(true);\n  }\n  /**\n   * Sign up\n   *\n   * @param user\n   */\n  signUp(user) {\n    return this._httpClient.post('api/auth/sign-up', user);\n  }\n  /**\n   * Unlock session\n   *\n   * @param credentials\n   */\n  unlockSession(credentials) {\n    return this._httpClient.post('api/auth/unlock-session', credentials);\n  }\n  /**\n   * Check the authentication status\n   */\n  check() {\n    // Check if the user is logged in\n    if (this._authenticated) {\n      return of(true);\n    }\n    // Check the access token availability\n    if (!this.accessToken) {\n      return of(false);\n    }\n    // Check the access token expire date\n    if (AuthUtils.isTokenExpired(this.accessToken)) {\n      return of(false);\n    }\n    // If the access token exists, and it didn't expire, sign in using it\n    return this.signInUsingToken();\n  }\n  static #_ = this.ɵfac = function AuthService_Factory(t) {\n    return new (t || AuthService)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthService,\n    factory: AuthService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["HttpClient","inject","AuthUtils","UserService","catchError","of","switchMap","throwError","AuthService","constructor","_authenticated","_httpClient","_userService","accessToken","token","localStorage","setItem","getItem","forgotPassword","email","post","resetPassword","password","signIn","credentials","pipe","response","user","signInUsingToken","signOut","removeItem","signUp","unlockSession","check","isTokenExpired","_","_2","factory","ɵfac","providedIn"],"sources":["/Users/tusharphalke/Documents/Freelancing_Work/rrms_frontend/src/app/core/auth/auth.service.ts"],"sourcesContent":["import { HttpClient } from '@angular/common/http';\nimport { inject, Injectable } from '@angular/core';\nimport { AuthUtils } from 'app/core/auth/auth.utils';\nimport { UserService } from 'app/core/user/user.service';\nimport { catchError, Observable, of, switchMap, throwError } from 'rxjs';\n\n@Injectable({providedIn: 'root'})\nexport class AuthService\n{\n    private _authenticated: boolean = false;\n    private _httpClient = inject(HttpClient);\n    private _userService = inject(UserService);\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Accessors\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Setter & getter for access token\n     */\n    set accessToken(token: string)\n    {\n        localStorage.setItem('accessToken', token);\n    }\n\n    get accessToken(): string\n    {\n        return localStorage.getItem('accessToken') ?? '';\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Public methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Forgot password\n     *\n     * @param email\n     */\n    forgotPassword(email: string): Observable<any>\n    {\n        return this._httpClient.post('api/auth/forgot-password', email);\n    }\n\n    /**\n     * Reset password\n     *\n     * @param password\n     */\n    resetPassword(password: string): Observable<any>\n    {\n        return this._httpClient.post('api/auth/reset-password', password);\n    }\n\n    /**\n     * Sign in\n     *\n     * @param credentials\n     */\n    signIn(credentials: { email: string; password: string }): Observable<any>\n    {\n        // Throw error, if the user is already logged in\n        if ( this._authenticated )\n        {\n            return throwError('User is already logged in.');\n        }\n\n        return this._httpClient.post('api/auth/sign-in', credentials).pipe(\n            switchMap((response: any) =>\n            {\n                // Store the access token in the local storage\n                this.accessToken = response.accessToken;\n\n                // Set the authenticated flag to true\n                this._authenticated = true;\n\n                // Store the user on the user service\n                this._userService.user = response.user;\n\n                // Return a new observable with the response\n                return of(response);\n            }),\n        );\n    }\n\n    /**\n     * Sign in using the access token\n     */\n    signInUsingToken(): Observable<any>\n    {\n        // Sign in using the token\n        return this._httpClient.post('api/auth/sign-in-with-token', {\n            accessToken: this.accessToken,\n        }).pipe(\n            catchError(() =>\n\n                // Return false\n                of(false),\n            ),\n            switchMap((response: any) =>\n            {\n                // Replace the access token with the new one if it's available on\n                // the response object.\n                //\n                // This is an added optional step for better security. Once you sign\n                // in using the token, you should generate a new one on the server\n                // side and attach it to the response object. Then the following\n                // piece of code can replace the token with the refreshed one.\n                if ( response.accessToken )\n                {\n                    this.accessToken = response.accessToken;\n                }\n\n                // Set the authenticated flag to true\n                this._authenticated = true;\n\n                // Store the user on the user service\n                this._userService.user = response.user;\n\n                // Return true\n                return of(true);\n            }),\n        );\n    }\n\n    /**\n     * Sign out\n     */\n    signOut(): Observable<any>\n    {\n        // Remove the access token from the local storage\n        localStorage.removeItem('accessToken');\n\n        // Set the authenticated flag to false\n        this._authenticated = false;\n\n        // Return the observable\n        return of(true);\n    }\n\n    /**\n     * Sign up\n     *\n     * @param user\n     */\n    signUp(user: { name: string; email: string; password: string; company: string }): Observable<any>\n    {\n        return this._httpClient.post('api/auth/sign-up', user);\n    }\n\n    /**\n     * Unlock session\n     *\n     * @param credentials\n     */\n    unlockSession(credentials: { email: string; password: string }): Observable<any>\n    {\n        return this._httpClient.post('api/auth/unlock-session', credentials);\n    }\n\n    /**\n     * Check the authentication status\n     */\n    check(): Observable<boolean>\n    {\n        // Check if the user is logged in\n        if ( this._authenticated )\n        {\n            return of(true);\n        }\n\n        // Check the access token availability\n        if ( !this.accessToken )\n        {\n            return of(false);\n        }\n\n        // Check the access token expire date\n        if ( AuthUtils.isTokenExpired(this.accessToken) )\n        {\n            return of(false);\n        }\n\n        // If the access token exists, and it didn't expire, sign in using it\n        return this.signInUsingToken();\n    }\n}\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,sBAAsB;AACjD,SAASC,MAAM,QAAoB,eAAe;AAClD,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SAASC,WAAW,QAAQ,4BAA4B;AACxD,SAASC,UAAU,EAAcC,EAAE,EAAEC,SAAS,EAAEC,UAAU,QAAQ,MAAM;;AAGxE,OAAM,MAAOC,WAAW;EADxBC,YAAA;IAGY,KAAAC,cAAc,GAAY,KAAK;IAC/B,KAAAC,WAAW,GAAGV,MAAM,CAACD,UAAU,CAAC;IAChC,KAAAY,YAAY,GAAGX,MAAM,CAACE,WAAW,CAAC;;EAE1C;EACA;EACA;EAEA;;;EAGA,IAAIU,WAAWA,CAACC,KAAa;IAEzBC,YAAY,CAACC,OAAO,CAAC,aAAa,EAAEF,KAAK,CAAC;EAC9C;EAEA,IAAID,WAAWA,CAAA;IAEX,OAAOE,YAAY,CAACE,OAAO,CAAC,aAAa,CAAC,IAAI,EAAE;EACpD;EAEA;EACA;EACA;EAEA;;;;;EAKAC,cAAcA,CAACC,KAAa;IAExB,OAAO,IAAI,CAACR,WAAW,CAACS,IAAI,CAAC,0BAA0B,EAAED,KAAK,CAAC;EACnE;EAEA;;;;;EAKAE,aAAaA,CAACC,QAAgB;IAE1B,OAAO,IAAI,CAACX,WAAW,CAACS,IAAI,CAAC,yBAAyB,EAAEE,QAAQ,CAAC;EACrE;EAEA;;;;;EAKAC,MAAMA,CAACC,WAAgD;IAEnD;IACA,IAAK,IAAI,CAACd,cAAc,EACxB;MACI,OAAOH,UAAU,CAAC,4BAA4B,CAAC;;IAGnD,OAAO,IAAI,CAACI,WAAW,CAACS,IAAI,CAAC,kBAAkB,EAAEI,WAAW,CAAC,CAACC,IAAI,CAC9DnB,SAAS,CAAEoB,QAAa,IAAI;MAExB;MACA,IAAI,CAACb,WAAW,GAAGa,QAAQ,CAACb,WAAW;MAEvC;MACA,IAAI,CAACH,cAAc,GAAG,IAAI;MAE1B;MACA,IAAI,CAACE,YAAY,CAACe,IAAI,GAAGD,QAAQ,CAACC,IAAI;MAEtC;MACA,OAAOtB,EAAE,CAACqB,QAAQ,CAAC;IACvB,CAAC,CAAC,CACL;EACL;EAEA;;;EAGAE,gBAAgBA,CAAA;IAEZ;IACA,OAAO,IAAI,CAACjB,WAAW,CAACS,IAAI,CAAC,6BAA6B,EAAE;MACxDP,WAAW,EAAE,IAAI,CAACA;KACrB,CAAC,CAACY,IAAI,CACHrB,UAAU,CAAC;IAEP;IACAC,EAAE,CAAC,KAAK,CAAC,CACZ,EACDC,SAAS,CAAEoB,QAAa,IAAI;MAExB;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAKA,QAAQ,CAACb,WAAW,EACzB;QACI,IAAI,CAACA,WAAW,GAAGa,QAAQ,CAACb,WAAW;;MAG3C;MACA,IAAI,CAACH,cAAc,GAAG,IAAI;MAE1B;MACA,IAAI,CAACE,YAAY,CAACe,IAAI,GAAGD,QAAQ,CAACC,IAAI;MAEtC;MACA,OAAOtB,EAAE,CAAC,IAAI,CAAC;IACnB,CAAC,CAAC,CACL;EACL;EAEA;;;EAGAwB,OAAOA,CAAA;IAEH;IACAd,YAAY,CAACe,UAAU,CAAC,aAAa,CAAC;IAEtC;IACA,IAAI,CAACpB,cAAc,GAAG,KAAK;IAE3B;IACA,OAAOL,EAAE,CAAC,IAAI,CAAC;EACnB;EAEA;;;;;EAKA0B,MAAMA,CAACJ,IAAwE;IAE3E,OAAO,IAAI,CAAChB,WAAW,CAACS,IAAI,CAAC,kBAAkB,EAAEO,IAAI,CAAC;EAC1D;EAEA;;;;;EAKAK,aAAaA,CAACR,WAAgD;IAE1D,OAAO,IAAI,CAACb,WAAW,CAACS,IAAI,CAAC,yBAAyB,EAAEI,WAAW,CAAC;EACxE;EAEA;;;EAGAS,KAAKA,CAAA;IAED;IACA,IAAK,IAAI,CAACvB,cAAc,EACxB;MACI,OAAOL,EAAE,CAAC,IAAI,CAAC;;IAGnB;IACA,IAAK,CAAC,IAAI,CAACQ,WAAW,EACtB;MACI,OAAOR,EAAE,CAAC,KAAK,CAAC;;IAGpB;IACA,IAAKH,SAAS,CAACgC,cAAc,CAAC,IAAI,CAACrB,WAAW,CAAC,EAC/C;MACI,OAAOR,EAAE,CAAC,KAAK,CAAC;;IAGpB;IACA,OAAO,IAAI,CAACuB,gBAAgB,EAAE;EAClC;EAAC,QAAAO,CAAA,G;qBAlLQ3B,WAAW;EAAA;EAAA,QAAA4B,EAAA,G;WAAX5B,WAAW;IAAA6B,OAAA,EAAX7B,WAAW,CAAA8B,IAAA;IAAAC,UAAA,EADC;EAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}