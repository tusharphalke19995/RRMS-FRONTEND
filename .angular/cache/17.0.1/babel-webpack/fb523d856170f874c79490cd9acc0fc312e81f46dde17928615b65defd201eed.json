{"ast":null,"code":"import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ScrollbarGeometry, ScrollbarPosition } from '@fuse/directives/scrollbar/scrollbar.types';\nimport { merge } from 'lodash-es';\nimport PerfectScrollbar from 'perfect-scrollbar';\nimport { debounceTime, fromEvent, Subject, takeUntil } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/cdk/platform\";\nimport * as i2 from \"@angular/router\";\n/**\n * Wrapper directive for the Perfect Scrollbar: https://github.com/mdbootstrap/perfect-scrollbar\n */\nexport class FuseScrollbarDirective {\n  /**\n   * Constructor\n   */\n  constructor(_elementRef, _platform, _router) {\n    this._elementRef = _elementRef;\n    this._platform = _platform;\n    this._router = _router;\n    /* eslint-enable @typescript-eslint/naming-convention */\n    this.fuseScrollbar = true;\n    this._unsubscribeAll = new Subject();\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Getter for _elementRef\n   */\n  get elementRef() {\n    return this._elementRef;\n  }\n  /**\n   * Getter for _ps\n   */\n  get ps() {\n    return this._ps;\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Lifecycle hooks\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * On changes\n   *\n   * @param changes\n   */\n  ngOnChanges(changes) {\n    // Enabled\n    if ('fuseScrollbar' in changes) {\n      // Interpret empty string as 'true'\n      this.fuseScrollbar = coerceBooleanProperty(changes.fuseScrollbar.currentValue);\n      // If enabled, init the directive\n      if (this.fuseScrollbar) {\n        this._init();\n      }\n      // Otherwise destroy it\n      else {\n        this._destroy();\n      }\n    }\n    // Scrollbar options\n    if ('fuseScrollbarOptions' in changes) {\n      // Merge the options\n      this._options = merge({}, this._options, changes.fuseScrollbarOptions.currentValue);\n      // Return if not initialized\n      if (!this._ps) {\n        return;\n      }\n      // Destroy and re-init the PerfectScrollbar to update its options\n      setTimeout(() => {\n        this._destroy();\n      });\n      setTimeout(() => {\n        this._init();\n      });\n    }\n  }\n  /**\n   * On init\n   */\n  ngOnInit() {\n    // Subscribe to window resize event\n    fromEvent(window, 'resize').pipe(takeUntil(this._unsubscribeAll), debounceTime(150)).subscribe(() => {\n      // Update the PerfectScrollbar\n      this.update();\n    });\n  }\n  /**\n   * On destroy\n   */\n  ngOnDestroy() {\n    this._destroy();\n    // Unsubscribe from all subscriptions\n    this._unsubscribeAll.next(null);\n    this._unsubscribeAll.complete();\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Is enabled\n   */\n  isEnabled() {\n    return this.fuseScrollbar;\n  }\n  /**\n   * Update the scrollbar\n   */\n  update() {\n    // Return if not initialized\n    if (!this._ps) {\n      return;\n    }\n    // Update the PerfectScrollbar\n    this._ps.update();\n  }\n  /**\n   * Destroy the scrollbar\n   */\n  destroy() {\n    this.ngOnDestroy();\n  }\n  /**\n   * Returns the geometry of the scrollable element\n   *\n   * @param prefix\n   */\n  geometry(prefix = 'scroll') {\n    return new ScrollbarGeometry(this._elementRef.nativeElement[prefix + 'Left'], this._elementRef.nativeElement[prefix + 'Top'], this._elementRef.nativeElement[prefix + 'Width'], this._elementRef.nativeElement[prefix + 'Height']);\n  }\n  /**\n   * Returns the position of the scrollable element\n   *\n   * @param absolute\n   */\n  position(absolute = false) {\n    let scrollbarPosition;\n    if (!absolute && this._ps) {\n      scrollbarPosition = new ScrollbarPosition(this._ps.reach.x || 0, this._ps.reach.y || 0);\n    } else {\n      scrollbarPosition = new ScrollbarPosition(this._elementRef.nativeElement.scrollLeft, this._elementRef.nativeElement.scrollTop);\n    }\n    return scrollbarPosition;\n  }\n  /**\n   * Scroll to\n   *\n   * @param x\n   * @param y\n   * @param speed\n   */\n  scrollTo(x, y, speed) {\n    if (y == null && speed == null) {\n      this.animateScrolling('scrollTop', x, speed);\n    } else {\n      if (x != null) {\n        this.animateScrolling('scrollLeft', x, speed);\n      }\n      if (y != null) {\n        this.animateScrolling('scrollTop', y, speed);\n      }\n    }\n  }\n  /**\n   * Scroll to X\n   *\n   * @param x\n   * @param speed\n   */\n  scrollToX(x, speed) {\n    this.animateScrolling('scrollLeft', x, speed);\n  }\n  /**\n   * Scroll to Y\n   *\n   * @param y\n   * @param speed\n   */\n  scrollToY(y, speed) {\n    this.animateScrolling('scrollTop', y, speed);\n  }\n  /**\n   * Scroll to top\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToTop(offset = 0, speed) {\n    this.animateScrolling('scrollTop', offset, speed);\n  }\n  /**\n   * Scroll to bottom\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToBottom(offset = 0, speed) {\n    const top = this._elementRef.nativeElement.scrollHeight - this._elementRef.nativeElement.clientHeight;\n    this.animateScrolling('scrollTop', top - offset, speed);\n  }\n  /**\n   * Scroll to left\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToLeft(offset = 0, speed) {\n    this.animateScrolling('scrollLeft', offset, speed);\n  }\n  /**\n   * Scroll to right\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToRight(offset = 0, speed) {\n    const left = this._elementRef.nativeElement.scrollWidth - this._elementRef.nativeElement.clientWidth;\n    this.animateScrolling('scrollLeft', left - offset, speed);\n  }\n  /**\n   * Scroll to element\n   *\n   * @param qs\n   * @param offset\n   * @param ignoreVisible If true, scrollToElement won't happen if element is already inside the current viewport\n   * @param speed\n   */\n  scrollToElement(qs, offset = 0, ignoreVisible = false, speed) {\n    const element = this._elementRef.nativeElement.querySelector(qs);\n    if (!element) {\n      return;\n    }\n    const elementPos = element.getBoundingClientRect();\n    const scrollerPos = this._elementRef.nativeElement.getBoundingClientRect();\n    if (this._elementRef.nativeElement.classList.contains('ps--active-x')) {\n      if (ignoreVisible && elementPos.right <= scrollerPos.right - Math.abs(offset)) {\n        return;\n      }\n      const currentPos = this._elementRef.nativeElement['scrollLeft'];\n      const position = elementPos.left - scrollerPos.left + currentPos;\n      this.animateScrolling('scrollLeft', position + offset, speed);\n    }\n    if (this._elementRef.nativeElement.classList.contains('ps--active-y')) {\n      if (ignoreVisible && elementPos.bottom <= scrollerPos.bottom - Math.abs(offset)) {\n        return;\n      }\n      const currentPos = this._elementRef.nativeElement['scrollTop'];\n      const position = elementPos.top - scrollerPos.top + currentPos;\n      this.animateScrolling('scrollTop', position + offset, speed);\n    }\n  }\n  /**\n   * Animate scrolling\n   *\n   * @param target\n   * @param value\n   * @param speed\n   */\n  animateScrolling(target, value, speed) {\n    if (this._animation) {\n      window.cancelAnimationFrame(this._animation);\n      this._animation = null;\n    }\n    if (!speed || typeof window === 'undefined') {\n      this._elementRef.nativeElement[target] = value;\n    } else if (value !== this._elementRef.nativeElement[target]) {\n      let newValue = 0;\n      let scrollCount = 0;\n      let oldTimestamp = performance.now();\n      let oldValue = this._elementRef.nativeElement[target];\n      const cosParameter = (oldValue - value) / 2;\n      const step = newTimestamp => {\n        scrollCount += Math.PI / (speed / (newTimestamp - oldTimestamp));\n        newValue = Math.round(value + cosParameter + cosParameter * Math.cos(scrollCount));\n        // Only continue animation if scroll position has not changed\n        if (this._elementRef.nativeElement[target] === oldValue) {\n          if (scrollCount >= Math.PI) {\n            this.animateScrolling(target, value, 0);\n          } else {\n            this._elementRef.nativeElement[target] = newValue;\n            // On a zoomed out page the resulting offset may differ\n            oldValue = this._elementRef.nativeElement[target];\n            oldTimestamp = newTimestamp;\n            this._animation = window.requestAnimationFrame(step);\n          }\n        }\n      };\n      window.requestAnimationFrame(step);\n    }\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Private methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Initialize\n   *\n   * @private\n   */\n  _init() {\n    // Return if already initialized\n    if (this._ps) {\n      return;\n    }\n    // Return if on mobile or not on browser\n    if (this._platform.ANDROID || this._platform.IOS || !this._platform.isBrowser) {\n      this.fuseScrollbar = false;\n      return;\n    }\n    // Initialize the PerfectScrollbar\n    this._ps = new PerfectScrollbar(this._elementRef.nativeElement, {\n      ...this._options\n    });\n  }\n  /**\n   * Destroy\n   *\n   * @private\n   */\n  _destroy() {\n    // Return if not initialized\n    if (!this._ps) {\n      return;\n    }\n    // Destroy the PerfectScrollbar\n    this._ps.destroy();\n    // Clean up\n    this._ps = null;\n  }\n  static #_ = this.ɵfac = function FuseScrollbarDirective_Factory(t) {\n    return new (t || FuseScrollbarDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.Platform), i0.ɵɵdirectiveInject(i2.Router));\n  };\n  static #_2 = this.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: FuseScrollbarDirective,\n    selectors: [[\"\", \"fuseScrollbar\", \"\"]],\n    inputs: {\n      fuseScrollbar: \"fuseScrollbar\",\n      fuseScrollbarOptions: \"fuseScrollbarOptions\"\n    },\n    exportAs: [\"fuseScrollbar\"],\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n}","map":{"version":3,"names":["coerceBooleanProperty","ScrollbarGeometry","ScrollbarPosition","merge","PerfectScrollbar","debounceTime","fromEvent","Subject","takeUntil","FuseScrollbarDirective","constructor","_elementRef","_platform","_router","fuseScrollbar","_unsubscribeAll","elementRef","ps","_ps","ngOnChanges","changes","currentValue","_init","_destroy","_options","fuseScrollbarOptions","setTimeout","ngOnInit","window","pipe","subscribe","update","ngOnDestroy","next","complete","isEnabled","destroy","geometry","prefix","nativeElement","position","absolute","scrollbarPosition","reach","x","y","scrollLeft","scrollTop","scrollTo","speed","animateScrolling","scrollToX","scrollToY","scrollToTop","offset","scrollToBottom","top","scrollHeight","clientHeight","scrollToLeft","scrollToRight","left","scrollWidth","clientWidth","scrollToElement","qs","ignoreVisible","element","querySelector","elementPos","getBoundingClientRect","scrollerPos","classList","contains","right","Math","abs","currentPos","bottom","target","value","_animation","cancelAnimationFrame","newValue","scrollCount","oldTimestamp","performance","now","oldValue","cosParameter","step","newTimestamp","PI","round","cos","requestAnimationFrame","ANDROID","IOS","isBrowser","_","i0","ɵɵdirectiveInject","ElementRef","i1","Platform","i2","Router","_2","selectors","inputs","exportAs","standalone","features","ɵɵNgOnChangesFeature"],"sources":["/Users/tusharphalke/Documents/Freelancing_Work/rrms_frontend/src/@fuse/directives/scrollbar/scrollbar.directive.ts"],"sourcesContent":["import { BooleanInput, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { Directive, ElementRef, Input, OnChanges, OnDestroy, OnInit, SimpleChanges } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { ScrollbarGeometry, ScrollbarPosition } from '@fuse/directives/scrollbar/scrollbar.types';\nimport { merge } from 'lodash-es';\nimport PerfectScrollbar from 'perfect-scrollbar';\nimport { debounceTime, fromEvent, Subject, takeUntil } from 'rxjs';\n\n/**\n * Wrapper directive for the Perfect Scrollbar: https://github.com/mdbootstrap/perfect-scrollbar\n */\n@Directive({\n    selector  : '[fuseScrollbar]',\n    exportAs  : 'fuseScrollbar',\n    standalone: true,\n})\nexport class FuseScrollbarDirective implements OnChanges, OnInit, OnDestroy\n{\n    /* eslint-disable @typescript-eslint/naming-convention */\n    static ngAcceptInputType_fuseScrollbar: BooleanInput;\n    /* eslint-enable @typescript-eslint/naming-convention */\n\n    @Input() fuseScrollbar: boolean = true;\n    @Input() fuseScrollbarOptions: PerfectScrollbar.Options;\n\n    private _animation: number;\n    private _options: PerfectScrollbar.Options;\n    private _ps: PerfectScrollbar;\n    private _unsubscribeAll: Subject<any> = new Subject<any>();\n\n    /**\n     * Constructor\n     */\n    constructor(\n        private _elementRef: ElementRef,\n        private _platform: Platform,\n        private _router: Router,\n    )\n    {\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Accessors\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Getter for _elementRef\n     */\n    get elementRef(): ElementRef\n    {\n        return this._elementRef;\n    }\n\n    /**\n     * Getter for _ps\n     */\n    get ps(): PerfectScrollbar | null\n    {\n        return this._ps;\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Lifecycle hooks\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * On changes\n     *\n     * @param changes\n     */\n    ngOnChanges(changes: SimpleChanges): void\n    {\n        // Enabled\n        if ( 'fuseScrollbar' in changes )\n        {\n            // Interpret empty string as 'true'\n            this.fuseScrollbar = coerceBooleanProperty(changes.fuseScrollbar.currentValue);\n\n            // If enabled, init the directive\n            if ( this.fuseScrollbar )\n            {\n                this._init();\n            }\n            // Otherwise destroy it\n            else\n            {\n                this._destroy();\n            }\n        }\n\n        // Scrollbar options\n        if ( 'fuseScrollbarOptions' in changes )\n        {\n            // Merge the options\n            this._options = merge({}, this._options, changes.fuseScrollbarOptions.currentValue);\n\n            // Return if not initialized\n            if ( !this._ps )\n            {\n                return;\n            }\n\n            // Destroy and re-init the PerfectScrollbar to update its options\n            setTimeout(() =>\n            {\n                this._destroy();\n            });\n\n            setTimeout(() =>\n            {\n                this._init();\n            });\n        }\n    }\n\n    /**\n     * On init\n     */\n    ngOnInit(): void\n    {\n        // Subscribe to window resize event\n        fromEvent(window, 'resize')\n            .pipe(\n                takeUntil(this._unsubscribeAll),\n                debounceTime(150),\n            )\n            .subscribe(() =>\n            {\n                // Update the PerfectScrollbar\n                this.update();\n            });\n    }\n\n    /**\n     * On destroy\n     */\n    ngOnDestroy(): void\n    {\n        this._destroy();\n\n        // Unsubscribe from all subscriptions\n        this._unsubscribeAll.next(null);\n        this._unsubscribeAll.complete();\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Public methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Is enabled\n     */\n    isEnabled(): boolean\n    {\n        return this.fuseScrollbar;\n    }\n\n    /**\n     * Update the scrollbar\n     */\n    update(): void\n    {\n        // Return if not initialized\n        if ( !this._ps )\n        {\n            return;\n        }\n\n        // Update the PerfectScrollbar\n        this._ps.update();\n    }\n\n    /**\n     * Destroy the scrollbar\n     */\n    destroy(): void\n    {\n        this.ngOnDestroy();\n    }\n\n    /**\n     * Returns the geometry of the scrollable element\n     *\n     * @param prefix\n     */\n    geometry(prefix: string = 'scroll'): ScrollbarGeometry\n    {\n        return new ScrollbarGeometry(\n            this._elementRef.nativeElement[prefix + 'Left'],\n            this._elementRef.nativeElement[prefix + 'Top'],\n            this._elementRef.nativeElement[prefix + 'Width'],\n            this._elementRef.nativeElement[prefix + 'Height']);\n    }\n\n    /**\n     * Returns the position of the scrollable element\n     *\n     * @param absolute\n     */\n    position(absolute: boolean = false): ScrollbarPosition\n    {\n        let scrollbarPosition;\n\n        if ( !absolute && this._ps )\n        {\n            scrollbarPosition = new ScrollbarPosition(\n                this._ps.reach.x || 0,\n                this._ps.reach.y || 0,\n            );\n        }\n        else\n        {\n            scrollbarPosition = new ScrollbarPosition(\n                this._elementRef.nativeElement.scrollLeft,\n                this._elementRef.nativeElement.scrollTop,\n            );\n        }\n\n        return scrollbarPosition;\n    }\n\n    /**\n     * Scroll to\n     *\n     * @param x\n     * @param y\n     * @param speed\n     */\n    scrollTo(x: number, y?: number, speed?: number): void\n    {\n        if ( y == null && speed == null )\n        {\n            this.animateScrolling('scrollTop', x, speed);\n        }\n        else\n        {\n            if ( x != null )\n            {\n                this.animateScrolling('scrollLeft', x, speed);\n            }\n\n            if ( y != null )\n            {\n                this.animateScrolling('scrollTop', y, speed);\n            }\n        }\n    }\n\n    /**\n     * Scroll to X\n     *\n     * @param x\n     * @param speed\n     */\n    scrollToX(x: number, speed?: number): void\n    {\n        this.animateScrolling('scrollLeft', x, speed);\n    }\n\n    /**\n     * Scroll to Y\n     *\n     * @param y\n     * @param speed\n     */\n    scrollToY(y: number, speed?: number): void\n    {\n        this.animateScrolling('scrollTop', y, speed);\n    }\n\n    /**\n     * Scroll to top\n     *\n     * @param offset\n     * @param speed\n     */\n    scrollToTop(offset: number = 0, speed?: number): void\n    {\n        this.animateScrolling('scrollTop', offset, speed);\n    }\n\n    /**\n     * Scroll to bottom\n     *\n     * @param offset\n     * @param speed\n     */\n    scrollToBottom(offset: number = 0, speed?: number): void\n    {\n        const top = this._elementRef.nativeElement.scrollHeight - this._elementRef.nativeElement.clientHeight;\n        this.animateScrolling('scrollTop', top - offset, speed);\n    }\n\n    /**\n     * Scroll to left\n     *\n     * @param offset\n     * @param speed\n     */\n    scrollToLeft(offset: number = 0, speed?: number): void\n    {\n        this.animateScrolling('scrollLeft', offset, speed);\n    }\n\n    /**\n     * Scroll to right\n     *\n     * @param offset\n     * @param speed\n     */\n    scrollToRight(offset: number = 0, speed?: number): void\n    {\n        const left = this._elementRef.nativeElement.scrollWidth - this._elementRef.nativeElement.clientWidth;\n        this.animateScrolling('scrollLeft', left - offset, speed);\n    }\n\n    /**\n     * Scroll to element\n     *\n     * @param qs\n     * @param offset\n     * @param ignoreVisible If true, scrollToElement won't happen if element is already inside the current viewport\n     * @param speed\n     */\n    scrollToElement(qs: string, offset: number = 0, ignoreVisible: boolean = false, speed?: number): void\n    {\n        const element = this._elementRef.nativeElement.querySelector(qs);\n\n        if ( !element )\n        {\n            return;\n        }\n\n        const elementPos = element.getBoundingClientRect();\n        const scrollerPos = this._elementRef.nativeElement.getBoundingClientRect();\n\n        if ( this._elementRef.nativeElement.classList.contains('ps--active-x') )\n        {\n            if ( ignoreVisible && elementPos.right <= (scrollerPos.right - Math.abs(offset)) )\n            {\n                return;\n            }\n\n            const currentPos = this._elementRef.nativeElement['scrollLeft'];\n            const position = elementPos.left - scrollerPos.left + currentPos;\n\n            this.animateScrolling('scrollLeft', position + offset, speed);\n        }\n\n        if ( this._elementRef.nativeElement.classList.contains('ps--active-y') )\n        {\n            if ( ignoreVisible && elementPos.bottom <= (scrollerPos.bottom - Math.abs(offset)) )\n            {\n                return;\n            }\n\n            const currentPos = this._elementRef.nativeElement['scrollTop'];\n            const position = elementPos.top - scrollerPos.top + currentPos;\n\n            this.animateScrolling('scrollTop', position + offset, speed);\n        }\n    }\n\n    /**\n     * Animate scrolling\n     *\n     * @param target\n     * @param value\n     * @param speed\n     */\n    animateScrolling(target: string, value: number, speed?: number): void\n    {\n        if ( this._animation )\n        {\n            window.cancelAnimationFrame(this._animation);\n            this._animation = null;\n        }\n\n        if ( !speed || typeof window === 'undefined' )\n        {\n            this._elementRef.nativeElement[target] = value;\n        }\n        else if ( value !== this._elementRef.nativeElement[target] )\n        {\n            let newValue = 0;\n            let scrollCount = 0;\n\n            let oldTimestamp = performance.now();\n            let oldValue = this._elementRef.nativeElement[target];\n\n            const cosParameter = (oldValue - value) / 2;\n\n            const step = (newTimestamp: number): void =>\n            {\n                scrollCount += Math.PI / (speed / (newTimestamp - oldTimestamp));\n                newValue = Math.round(value + cosParameter + cosParameter * Math.cos(scrollCount));\n\n                // Only continue animation if scroll position has not changed\n                if ( this._elementRef.nativeElement[target] === oldValue )\n                {\n                    if ( scrollCount >= Math.PI )\n                    {\n                        this.animateScrolling(target, value, 0);\n                    }\n                    else\n                    {\n                        this._elementRef.nativeElement[target] = newValue;\n\n                        // On a zoomed out page the resulting offset may differ\n                        oldValue = this._elementRef.nativeElement[target];\n                        oldTimestamp = newTimestamp;\n\n                        this._animation = window.requestAnimationFrame(step);\n                    }\n                }\n            };\n\n            window.requestAnimationFrame(step);\n        }\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Private methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Initialize\n     *\n     * @private\n     */\n    private _init(): void\n    {\n        // Return if already initialized\n        if ( this._ps )\n        {\n            return;\n        }\n\n        // Return if on mobile or not on browser\n        if ( this._platform.ANDROID || this._platform.IOS || !this._platform.isBrowser )\n        {\n            this.fuseScrollbar = false;\n            return;\n        }\n\n        // Initialize the PerfectScrollbar\n        this._ps = new PerfectScrollbar(this._elementRef.nativeElement, {...this._options});\n    }\n\n    /**\n     * Destroy\n     *\n     * @private\n     */\n    private _destroy(): void\n    {\n        // Return if not initialized\n        if ( !this._ps )\n        {\n            return;\n        }\n\n        // Destroy the PerfectScrollbar\n        this._ps.destroy();\n\n        // Clean up\n        this._ps = null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}