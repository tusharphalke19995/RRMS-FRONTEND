{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Component, Input, TemplateRef, inject, ChangeDetectorRef, ElementRef, ViewContainerRef, Renderer2, Directive, Pipe, NgModule, makeEnvironmentProviders, APP_INITIALIZER } from '@angular/core';\nimport { of, take, from, map, Subject, BehaviorSubject, forkJoin, retry, tap, catchError, shareReplay, switchMap, combineLatest, EMPTY } from 'rxjs';\nimport { unflatten as unflatten$1, flatten as flatten$1 } from 'flat';\nclass DefaultLoader {\n  translations;\n  constructor(translations) {\n    this.translations = translations;\n  }\n  getTranslation(lang) {\n    return of(this.translations.get(lang) || {});\n  }\n}\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\nfunction getValue(obj, path) {\n  if (!obj) {\n    return obj;\n  }\n  /* For cases where the key is like: 'general.something.thing' */\n  if (Object.prototype.hasOwnProperty.call(obj, path)) {\n    return obj[path];\n  }\n  return path.split('.').reduce((p, c) => p?.[c], obj);\n}\nfunction setValue(obj, prop, val) {\n  obj = {\n    ...obj\n  };\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : {\n        ...acc[part]\n      };\n    }\n    return acc && acc[part];\n  }, obj);\n  return obj;\n}\nfunction size(collection) {\n  if (!collection) {\n    return 0;\n  }\n  if (Array.isArray(collection)) {\n    return collection.length;\n  }\n  if (isObject(collection)) {\n    return Object.keys(collection).length;\n  }\n  return collection ? collection.length : 0;\n}\nfunction isEmpty(collection) {\n  return size(collection) === 0;\n}\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\nfunction isString(val) {\n  return typeof val === 'string';\n}\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\nfunction isObject(item) {\n  return !!item && typeof item === 'object' && !Array.isArray(item);\n}\nfunction coerceArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\nfunction toCamelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => index == 0 ? word.toLowerCase() : word.toUpperCase()).replace(/\\s+|_|-|\\//g, '');\n}\nfunction isBrowser() {\n  return typeof window !== 'undefined';\n}\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\nfunction isDefined(value) {\n  return isNil(value) === false;\n}\nfunction toNumber(value) {\n  if (isNumber(value)) return value;\n  if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n    return Number(value);\n  }\n  return null;\n}\nfunction isScopeObject(item) {\n  return item && typeof item.scope === 'string';\n}\nfunction isScopeArray(item) {\n  return Array.isArray(item) && item.every(isScopeObject);\n}\nfunction hasInlineLoader(item) {\n  return item && isObject(item.loader);\n}\nfunction unflatten(obj) {\n  return unflatten$1(obj);\n}\nfunction flatten(obj) {\n  return flatten$1(obj, {\n    safe: true\n  });\n}\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n  providedIn: 'root',\n  factory: () => defaultConfig\n});\nconst defaultConfig = {\n  defaultLang: 'en',\n  reRenderOnLangChange: false,\n  prodMode: false,\n  failedRetries: 2,\n  fallbackLang: [],\n  availableLangs: [],\n  missingHandler: {\n    logMissingKey: true,\n    useFallbackTranslation: false,\n    allowEmpty: false\n  },\n  flatten: {\n    aot: false\n  },\n  interpolation: ['{{', '}}']\n};\nfunction translocoConfig(config = {}) {\n  return {\n    ...defaultConfig,\n    ...config,\n    missingHandler: {\n      ...defaultConfig.missingHandler,\n      ...config.missingHandler\n    },\n    flatten: {\n      ...defaultConfig.flatten,\n      ...config.flatten\n    }\n  };\n}\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\nclass DefaultTranspiler {\n  interpolationMatcher;\n  constructor(config) {\n    this.interpolationMatcher = resolveMatcher(config ?? defaultConfig);\n  }\n  transpile(value, params = {}, translation, key) {\n    if (isString(value)) {\n      return value.replace(this.interpolationMatcher, (_, match) => {\n        match = match.trim();\n        if (isDefined(params[match])) {\n          return params[match];\n        }\n        return isDefined(translation[match]) ? this.transpile(translation[match], params, translation, key) : '';\n      });\n    } else if (params) {\n      if (isObject(value)) {\n        value = this.handleObject(value, params, translation, key);\n      } else if (Array.isArray(value)) {\n        value = this.handleArray(value, params, translation, key);\n      }\n    }\n    return value;\n  }\n  /**\n   *\n   * @example\n   *\n   * const en = {\n   *  a: {\n   *    b: {\n   *      c: \"Hello {{ value }}\"\n   *    }\n   *  }\n   * }\n   *\n   * const params =  {\n   *  \"b.c\": { value: \"Transloco \"}\n   * }\n   *\n   * service.selectTranslate('a', params);\n   *\n   * // the first param will be the result of `en.a`.\n   * // the second param will be `params`.\n   * parser.transpile(value, params, {});\n   *\n   *\n   */\n  handleObject(value, params = {}, translation, key) {\n    let result = value;\n    Object.keys(params).forEach(p => {\n      // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n      const v = getValue(result, p);\n      // get the params of \"b.c\" => { value: \"Transloco\" }\n      const getParams = getValue(params, p);\n      // transpile the value => \"Hello Transloco\"\n      const transpiled = this.transpile(v, getParams, translation, key);\n      // set \"b.c\" to `transpiled`\n      result = setValue(result, p, transpiled);\n    });\n    return result;\n  }\n  handleArray(value, params = {}, translation, key) {\n    return value.map(v => this.transpile(v, params, translation, key));\n  }\n  static ɵfac = function DefaultTranspiler_Factory(t) {\n    return new (t || DefaultTranspiler)(i0.ɵɵinject(TRANSLOCO_CONFIG, 8));\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultTranspiler,\n    factory: DefaultTranspiler.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultTranspiler, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }];\n  }, null);\n})();\nfunction resolveMatcher(config) {\n  const [start, end] = config.interpolation;\n  return new RegExp(`${start}(.*?)${end}`, 'g');\n}\nfunction getFunctionArgs(argsString) {\n  const splitted = argsString ? argsString.split(',') : [];\n  const args = [];\n  for (let i = 0; i < splitted.length; i++) {\n    let value = splitted[i].trim();\n    while (value[value.length - 1] === '\\\\') {\n      i++;\n      value = value.replace('\\\\', ',') + splitted[i];\n    }\n    args.push(value);\n  }\n  return args;\n}\nclass FunctionalTranspiler extends DefaultTranspiler {\n  injector;\n  constructor(injector) {\n    super();\n    this.injector = injector;\n  }\n  transpile(value, params = {}, translation, key) {\n    let transpiled = value;\n    if (isString(value)) {\n      transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*?)\\)\\s*]]/g, (match, functionName, args) => {\n        try {\n          const func = this.injector.get(functionName);\n          return func.transpile(...getFunctionArgs(args));\n        } catch (e) {\n          let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n          if (e.message.includes('NullInjectorError')) {\n            message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n          }\n          throw new Error(message);\n        }\n      });\n    }\n    return super.transpile(transpiled, params, translation, key);\n  }\n  static ɵfac = function FunctionalTranspiler_Factory(t) {\n    return new (t || FunctionalTranspiler)(i0.ɵɵinject(i0.Injector));\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FunctionalTranspiler,\n    factory: FunctionalTranspiler.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FunctionalTranspiler, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i0.Injector\n    }];\n  }, null);\n})();\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\nclass DefaultHandler {\n  handle(key, config) {\n    if (config.missingHandler.logMissingKey && !config.prodMode) {\n      const msg = `Missing translation for '${key}'`;\n      console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n    }\n    return key;\n  }\n  static ɵfac = function DefaultHandler_Factory(t) {\n    return new (t || DefaultHandler)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultHandler,\n    factory: DefaultHandler.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultHandler, [{\n    type: Injectable\n  }], null, null);\n})();\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\nclass DefaultInterceptor {\n  preSaveTranslation(translation) {\n    return translation;\n  }\n  preSaveTranslationKey(_, value) {\n    return value;\n  }\n  static ɵfac = function DefaultInterceptor_Factory(t) {\n    return new (t || DefaultInterceptor)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultInterceptor,\n    factory: DefaultInterceptor.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultInterceptor, [{\n    type: Injectable\n  }], null, null);\n})();\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\nclass DefaultFallbackStrategy {\n  userConfig;\n  constructor(userConfig) {\n    this.userConfig = userConfig;\n  }\n  getNextLangs() {\n    const fallbackLang = this.userConfig.fallbackLang;\n    if (!fallbackLang) {\n      throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n    }\n    return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n  }\n  static ɵfac = function DefaultFallbackStrategy_Factory(t) {\n    return new (t || DefaultFallbackStrategy)(i0.ɵɵinject(TRANSLOCO_CONFIG));\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultFallbackStrategy,\n    factory: DefaultFallbackStrategy.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultFallbackStrategy, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\nfunction getScopeFromLang(lang) {\n  if (!lang) {\n    return '';\n  }\n  const split = lang.split('/');\n  split.pop();\n  return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\nfunction getLangFromScope(lang) {\n  if (!lang) {\n    return '';\n  }\n  return lang.split('/').pop();\n}\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\nfunction getPipeValue(str, value, char = '|') {\n  if (isString(str)) {\n    const splitted = str.split(char);\n    const lastItem = splitted.pop();\n    return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n  }\n  return [false, ''];\n}\nfunction shouldListenToLangChanges(service, lang) {\n  const [hasStatic] = getPipeValue(lang, 'static');\n  if (!hasStatic) {\n    // If we didn't get 'lang|static' check if it's set in the global level\n    return !!service.config.reRenderOnLangChange;\n  }\n  // We have 'lang|static' so don't listen to lang changes\n  return false;\n}\nfunction listenOrNotOperator(listenToLangChange) {\n  return listenToLangChange ? source => source : take(1);\n}\nfunction prependScope(inlineLoader, scope) {\n  return Object.keys(inlineLoader).reduce((acc, lang) => {\n    acc[`${scope}/${lang}`] = inlineLoader[lang];\n    return acc;\n  }, {});\n}\nfunction resolveInlineLoader(providerScope, scope) {\n  return hasInlineLoader(providerScope) ? prependScope(providerScope.loader, scope) : undefined;\n}\nfunction getEventPayload(lang) {\n  return {\n    scope: getScopeFromLang(lang) || null,\n    langName: getLangFromScope(lang)\n  };\n}\nfunction resolveLoader(options) {\n  const {\n    path,\n    inlineLoader,\n    mainLoader,\n    data\n  } = options;\n  if (inlineLoader) {\n    const pathLoader = inlineLoader[path];\n    if (isFunction(pathLoader) === false) {\n      throw `You're using an inline loader but didn't provide a loader for ${path}`;\n    }\n    return inlineLoader[path]().then(res => res.default ? res.default : res);\n  }\n  return mainLoader.getTranslation(path, data);\n}\nfunction getFallbacksLoaders({\n  mainLoader,\n  path,\n  data,\n  fallbackPath,\n  inlineLoader\n}) {\n  const paths = fallbackPath ? [path, fallbackPath] : [path];\n  return paths.map(path => {\n    const loader = resolveLoader({\n      path,\n      mainLoader,\n      inlineLoader,\n      data\n    });\n    return from(loader).pipe(map(translation => ({\n      translation,\n      lang: path\n    })));\n  });\n}\nlet service;\nfunction translate(key, params = {}, lang) {\n  return service.translate(key, params, lang);\n}\nfunction translateObject(key, params = {}, lang) {\n  return service.translateObject(key, params, lang);\n}\nclass TranslocoService {\n  loader;\n  parser;\n  missingHandler;\n  interceptor;\n  fallbackStrategy;\n  langChanges$;\n  subscription = null;\n  translations = new Map();\n  cache = new Map();\n  firstFallbackLang;\n  defaultLang = '';\n  availableLangs = [];\n  isResolvedMissingOnce = false;\n  lang;\n  failedLangs = new Set();\n  events = new Subject();\n  events$ = this.events.asObservable();\n  config;\n  constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n    this.loader = loader;\n    this.parser = parser;\n    this.missingHandler = missingHandler;\n    this.interceptor = interceptor;\n    this.fallbackStrategy = fallbackStrategy;\n    if (!this.loader) {\n      this.loader = new DefaultLoader(this.translations);\n    }\n    service = this;\n    this.config = JSON.parse(JSON.stringify(userConfig));\n    this.setAvailableLangs(this.config.availableLangs || []);\n    this.setFallbackLangForMissingTranslation(this.config);\n    this.setDefaultLang(this.config.defaultLang);\n    this.lang = new BehaviorSubject(this.getDefaultLang());\n    // Don't use distinctUntilChanged as we need the ability to update\n    // the value when using setTranslation or setTranslationKeys\n    this.langChanges$ = this.lang.asObservable();\n    /**\n     * When we have a failure, we want to define the next language that succeeded as the active\n     */\n    this.subscription = this.events$.subscribe(e => {\n      if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n        this.setActiveLang(e.payload.langName);\n      }\n    });\n  }\n  getDefaultLang() {\n    return this.defaultLang;\n  }\n  setDefaultLang(lang) {\n    this.defaultLang = lang;\n  }\n  getActiveLang() {\n    return this.lang.getValue();\n  }\n  setActiveLang(lang) {\n    this.parser.onLangChanged?.(lang);\n    this.lang.next(lang);\n    this.events.next({\n      type: 'langChanged',\n      payload: getEventPayload(lang)\n    });\n    return this;\n  }\n  setAvailableLangs(langs) {\n    this.availableLangs = langs;\n  }\n  /**\n   * Gets the available languages.\n   *\n   * @returns\n   * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n   * depending on how the available languages are set in your module.\n   */\n  getAvailableLangs() {\n    return this.availableLangs;\n  }\n  load(path, options = {}) {\n    const cached = this.cache.get(path);\n    if (cached) {\n      return cached;\n    }\n    let loadTranslation;\n    const isScope = this._isLangScoped(path);\n    let scope;\n    if (isScope) {\n      scope = getScopeFromLang(path);\n    }\n    const loadersOptions = {\n      path,\n      mainLoader: this.loader,\n      inlineLoader: options.inlineLoader,\n      data: isScope ? {\n        scope: scope\n      } : undefined\n    };\n    if (this.useFallbackTranslation(path)) {\n      // if the path is scope the fallback should be `scope/fallbackLang`;\n      const fallback = isScope ? `${scope}/${this.firstFallbackLang}` : this.firstFallbackLang;\n      const loaders = getFallbacksLoaders({\n        ...loadersOptions,\n        fallbackPath: fallback\n      });\n      loadTranslation = forkJoin(loaders);\n    } else {\n      const loader = resolveLoader(loadersOptions);\n      loadTranslation = from(loader);\n    }\n    const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap(translation => {\n      if (Array.isArray(translation)) {\n        translation.forEach(t => {\n          this.handleSuccess(t.lang, t.translation);\n          // Save the fallback in cache so we'll not create a redundant request\n          if (t.lang !== path) {\n            this.cache.set(t.lang, of({}));\n          }\n        });\n        return;\n      }\n      this.handleSuccess(path, translation);\n    }), catchError(error => {\n      if (!this.config.prodMode) {\n        console.error(`Error while trying to load \"${path}\"`, error);\n      }\n      return this.handleFailure(path, options);\n    }), shareReplay(1));\n    this.cache.set(path, load$);\n    return load$;\n  }\n  /**\n   * Gets the instant translated value of a key\n   *\n   * @example\n   *\n   * translate<string>('hello')\n   * translate('hello', { value: 'value' })\n   * translate<string[]>(['hello', 'key'])\n   * translate('hello', { }, 'en')\n   * translate('scope.someKey', { }, 'en')\n   */\n  translate(key, params = {}, lang = this.getActiveLang()) {\n    if (!key) return key;\n    const {\n      scope,\n      resolveLang\n    } = this.resolveLangAndScope(lang);\n    if (Array.isArray(key)) {\n      return key.map(k => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang));\n    }\n    key = scope ? `${scope}.${key}` : key;\n    const translation = this.getTranslation(resolveLang);\n    const value = translation[key];\n    if (!value) {\n      return this._handleMissingKey(key, value, params);\n    }\n    return this.parser.transpile(value, params, translation, key);\n  }\n  /**\n   * Gets the translated value of a key as observable\n   *\n   * @example\n   *\n   * selectTranslate<string>('hello').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n   *\n   */\n  selectTranslate(key, params, lang, _isObject = false) {\n    let inlineLoader;\n    const load = (lang, options) => this.load(lang, options).pipe(map(() => _isObject ? this.translateObject(key, params, lang) : this.translate(key, params, lang)));\n    if (isNil(lang)) {\n      return this.langChanges$.pipe(switchMap(lang => load(lang)));\n    }\n    if (isScopeArray(lang) || isScopeObject(lang)) {\n      // it's a scope object.\n      const providerScope = Array.isArray(lang) ? lang[0] : lang;\n      lang = providerScope.scope;\n      inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n    }\n    lang = lang;\n    if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n      return load(lang);\n    }\n    // it's a scope\n    const scope = lang;\n    return this.langChanges$.pipe(switchMap(lang => load(`${scope}/${lang}`, {\n      inlineLoader\n    })));\n  }\n  /**\n   * Whether the scope with lang\n   *\n   * @example\n   *\n   * todos/en => true\n   * todos => false\n   */\n  isScopeWithLang(lang) {\n    return this.isLang(getLangFromScope(lang));\n  }\n  translateObject(key, params = {}, lang = this.getActiveLang()) {\n    if (isString(key) || Array.isArray(key)) {\n      const {\n        resolveLang,\n        scope\n      } = this.resolveLangAndScope(lang);\n      if (Array.isArray(key)) {\n        return key.map(k => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang));\n      }\n      const translation = this.getTranslation(resolveLang);\n      key = scope ? `${scope}.${key}` : key;\n      const value = unflatten(this.getObjectByKey(translation, key));\n      /* If an empty object was returned we want to try and translate the key as a string and not an object */\n      return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation, key);\n    }\n    const translations = [];\n    for (const [_key, _params] of this.getEntries(key)) {\n      translations.push(this.translateObject(_key, _params, lang));\n    }\n    return translations;\n  }\n  selectTranslateObject(key, params, lang) {\n    if (isString(key) || Array.isArray(key)) {\n      return this.selectTranslate(key, params, lang, true);\n    }\n    const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n    /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n     * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n    return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map(value => {\n      const translations = [value];\n      for (const [_key, _params] of rest) {\n        translations.push(this.translateObject(_key, _params, lang));\n      }\n      return translations;\n    }));\n  }\n  getTranslation(langOrScope) {\n    if (langOrScope) {\n      if (this.isLang(langOrScope)) {\n        return this.translations.get(langOrScope) || {};\n      } else {\n        // This is a scope, build the scope value from the translation object\n        const {\n          scope,\n          resolveLang\n        } = this.resolveLangAndScope(langOrScope);\n        const translation = this.translations.get(resolveLang) || {};\n        return this.getObjectByKey(translation, scope);\n      }\n    }\n    return this.translations;\n  }\n  /**\n   * Gets an object of translations for a given language\n   *\n   * @example\n   *\n   * selectTranslation().subscribe() - will return the current lang translation\n   * selectTranslation('es').subscribe()\n   * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n   * selectTranslation('admin-page/es').subscribe()\n   */\n  selectTranslation(lang) {\n    let language$ = this.langChanges$;\n    if (lang) {\n      const scopeLangSpecified = getLangFromScope(lang) !== lang;\n      if (this.isLang(lang) || scopeLangSpecified) {\n        language$ = of(lang);\n      } else {\n        language$ = this.langChanges$.pipe(map(currentLang => `${lang}/${currentLang}`));\n      }\n    }\n    return language$.pipe(switchMap(language => this.load(language).pipe(map(() => this.getTranslation(language)))));\n  }\n  /**\n   * Sets or merge a given translation object to current lang\n   *\n   * @example\n   *\n   * setTranslation({ ... })\n   * setTranslation({ ... }, 'en')\n   * setTranslation({ ... }, 'es', { merge: false } )\n   * setTranslation({ ... }, 'todos/en', { merge: false } )\n   */\n  setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n    const defaults = {\n      merge: true,\n      emitChange: true\n    };\n    const mergedOptions = {\n      ...defaults,\n      ...options\n    };\n    const scope = getScopeFromLang(lang);\n    /**\n     * If this isn't a scope we use the whole translation as is\n     * otherwise we need to flat the scope and use it\n     */\n    let flattenScopeOrTranslation = translation;\n    // Merged the scoped language into the active language\n    if (scope) {\n      const key = this.getMappedScope(scope);\n      flattenScopeOrTranslation = flatten({\n        [key]: translation\n      });\n    }\n    const currentLang = scope ? getLangFromScope(lang) : lang;\n    const mergedTranslation = {\n      ...(mergedOptions.merge && this.getTranslation(currentLang)),\n      ...flattenScopeOrTranslation\n    };\n    const flattenTranslation = this.config.flatten.aot ? mergedTranslation : flatten(mergedTranslation);\n    const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n    this.translations.set(currentLang, withHook);\n    mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n  }\n  /**\n   * Sets translation key with given value\n   *\n   * @example\n   *\n   * setTranslationKey('key', 'value')\n   * setTranslationKey('key.nested', 'value')\n   * setTranslationKey('key.nested', 'value', 'en')\n   * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n   */\n  setTranslationKey(key, value,\n  // Todo: Add the lang to the options in v3\n  lang = this.getActiveLang(), options = {}) {\n    const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n    const newValue = {\n      [key]: withHook\n    };\n    this.setTranslation(newValue, lang, {\n      ...options,\n      merge: true\n    });\n  }\n  /**\n   * Sets the fallback lang for the currently active language\n   * @param fallbackLang\n   */\n  setFallbackLangForMissingTranslation({\n    fallbackLang\n  }) {\n    const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n    if (fallbackLang && this.useFallbackTranslation(lang)) {\n      this.firstFallbackLang = lang;\n    }\n  }\n  /**\n   * @internal\n   */\n  _handleMissingKey(key, value, params) {\n    if (this.config.missingHandler.allowEmpty && value === '') {\n      return '';\n    }\n    if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {\n      // We need to set it to true to prevent a loop\n      this.isResolvedMissingOnce = true;\n      const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n      this.isResolvedMissingOnce = false;\n      return fallbackValue;\n    }\n    return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n  }\n  /**\n   * @internal\n   */\n  _isLangScoped(lang) {\n    return this.getAvailableLangsIds().indexOf(lang) === -1;\n  }\n  /**\n   * Checks if a given string is one of the specified available languages.\n   * @returns\n   * True if the given string is an available language.\n   * False if the given string is not an available language.\n   */\n  isLang(lang) {\n    return this.getAvailableLangsIds().indexOf(lang) !== -1;\n  }\n  /**\n   * @internal\n   *\n   * We always want to make sure the global lang is loaded\n   * before loading the scope since you can access both via the pipe/directive.\n   */\n  _loadDependencies(path, inlineLoader) {\n    const mainLang = getLangFromScope(path);\n    if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n      return combineLatest([this.load(mainLang), this.load(path, {\n        inlineLoader\n      })]);\n    }\n    return this.load(path, {\n      inlineLoader\n    });\n  }\n  /**\n   * @internal\n   */\n  _completeScopeWithLang(langOrScope) {\n    if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {\n      return `${langOrScope}/${this.getActiveLang()}`;\n    }\n    return langOrScope;\n  }\n  /**\n   * @internal\n   */\n  _setScopeAlias(scope, alias) {\n    if (!this.config.scopeMapping) {\n      this.config.scopeMapping = {};\n    }\n    this.config.scopeMapping[scope] = alias;\n  }\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n      this.subscription = null;\n    }\n    // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.\n    // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from\n    // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created\n    // and destroyed per each HTTP request, but any service is not getting GC'd.\n    this.cache.clear();\n  }\n  isLoadedTranslation(lang) {\n    return size(this.getTranslation(lang));\n  }\n  getAvailableLangsIds() {\n    const first = this.getAvailableLangs()[0];\n    if (isString(first)) {\n      return this.getAvailableLangs();\n    }\n    return this.getAvailableLangs().map(l => l.id);\n  }\n  getMissingHandlerData() {\n    return {\n      ...this.config,\n      activeLang: this.getActiveLang(),\n      availableLangs: this.availableLangs,\n      defaultLang: this.defaultLang\n    };\n  }\n  /**\n   * Use a fallback translation set for missing keys of the primary language\n   * This is unrelated to the fallback language (which changes the active language)\n   */\n  useFallbackTranslation(lang) {\n    return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;\n  }\n  handleSuccess(lang, translation) {\n    this.setTranslation(translation, lang, {\n      emitChange: false\n    });\n    this.events.next({\n      wasFailure: !!this.failedLangs.size,\n      type: 'translationLoadSuccess',\n      payload: getEventPayload(lang)\n    });\n    this.failedLangs.forEach(l => this.cache.delete(l));\n    this.failedLangs.clear();\n  }\n  handleFailure(lang, loadOptions) {\n    // When starting to load a first choice language, initialize\n    // the failed counter and resolve the fallback langs.\n    if (isNil(loadOptions.failedCounter)) {\n      loadOptions.failedCounter = 0;\n      if (!loadOptions.fallbackLangs) {\n        loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n      }\n    }\n    const splitted = lang.split('/');\n    const fallbacks = loadOptions.fallbackLangs;\n    const nextLang = fallbacks[loadOptions.failedCounter];\n    this.failedLangs.add(lang);\n    // This handles the case where a loaded fallback language is requested again\n    if (this.cache.has(nextLang)) {\n      this.handleSuccess(nextLang, this.getTranslation(nextLang));\n      return EMPTY;\n    }\n    const isFallbackLang = nextLang === splitted[splitted.length - 1];\n    if (!nextLang || isFallbackLang) {\n      let msg = `Unable to load translation and all the fallback languages`;\n      if (splitted.length > 1) {\n        msg += `, did you misspelled the scope name?`;\n      }\n      throw new Error(msg);\n    }\n    let resolveLang = nextLang;\n    // if it's scoped lang\n    if (splitted.length > 1) {\n      // We need to resolve it to:\n      // todos/langNotExists => todos/nextLang\n      splitted[splitted.length - 1] = nextLang;\n      resolveLang = splitted.join('/');\n    }\n    loadOptions.failedCounter++;\n    this.events.next({\n      type: 'translationLoadFailure',\n      payload: getEventPayload(lang)\n    });\n    return this.load(resolveLang, loadOptions);\n  }\n  getMappedScope(scope) {\n    const {\n      scopeMapping = {}\n    } = this.config;\n    return scopeMapping[scope] || toCamelCase(scope);\n  }\n  /**\n   * If lang is scope we need to check the following cases:\n   * todos/es => in this case we should take `es` as lang\n   * todos => in this case we should set the active lang as lang\n   */\n  resolveLangAndScope(lang) {\n    let resolveLang = lang;\n    let scope;\n    if (this._isLangScoped(lang)) {\n      // en for example\n      const langFromScope = getLangFromScope(lang);\n      // en is lang\n      const hasLang = this.isLang(langFromScope);\n      // take en\n      resolveLang = hasLang ? langFromScope : this.getActiveLang();\n      // find the scope\n      scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n    }\n    return {\n      scope,\n      resolveLang\n    };\n  }\n  getObjectByKey(translation, key) {\n    const result = {};\n    const prefix = `${key}.`;\n    for (const currentKey in translation) {\n      if (currentKey.startsWith(prefix)) {\n        result[currentKey.replace(prefix, '')] = translation[currentKey];\n      }\n    }\n    return result;\n  }\n  getEntries(key) {\n    return key instanceof Map ? key.entries() : Object.entries(key);\n  }\n  static ɵfac = function TranslocoService_Factory(t) {\n    return new (t || TranslocoService)(i0.ɵɵinject(TRANSLOCO_LOADER, 8), i0.ɵɵinject(TRANSLOCO_TRANSPILER), i0.ɵɵinject(TRANSLOCO_MISSING_HANDLER), i0.ɵɵinject(TRANSLOCO_INTERCEPTOR), i0.ɵɵinject(TRANSLOCO_CONFIG), i0.ɵɵinject(TRANSLOCO_FALLBACK_STRATEGY));\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TranslocoService,\n    factory: TranslocoService.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LOADER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_TRANSPILER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_MISSING_HANDLER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_INTERCEPTOR]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_FALLBACK_STRATEGY]\n      }]\n    }];\n  }, null);\n})();\nclass TranslocoLoaderComponent {\n  html;\n  static ɵfac = function TranslocoLoaderComponent_Factory(t) {\n    return new (t || TranslocoLoaderComponent)();\n  };\n  static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TranslocoLoaderComponent,\n    selectors: [[\"ng-component\"]],\n    inputs: {\n      html: \"html\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[1, \"transloco-loader-template\", 3, \"innerHTML\"]],\n    template: function TranslocoLoaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"innerHTML\", ctx.html, i0.ɵɵsanitizeHtml);\n      }\n    },\n    encapsulation: 2\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoLoaderComponent, [{\n    type: Component,\n    args: [{\n      template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `,\n      standalone: true\n    }]\n  }], null, {\n    html: [{\n      type: Input\n    }]\n  });\n})();\nclass TemplateHandler {\n  view;\n  vcr;\n  constructor(view, vcr) {\n    this.view = view;\n    this.vcr = vcr;\n  }\n  attachView() {\n    if (this.view instanceof TemplateRef) {\n      this.vcr.createEmbeddedView(this.view);\n    } else if (isString(this.view)) {\n      const componentRef = this.vcr.createComponent(TranslocoLoaderComponent);\n      componentRef.instance.html = this.view;\n      componentRef.hostView.detectChanges();\n    } else {\n      this.vcr.createComponent(this.view);\n    }\n  }\n  detachView() {\n    this.vcr.clear();\n  }\n}\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\nclass LangResolver {\n  initialized = false;\n  // inline => provider => active\n  resolve({\n    inline,\n    provider,\n    active\n  }) {\n    let lang = active;\n    /**\n     * When the user changes the lang we need to update\n     * the view. Otherwise, the lang will remain the inline/provided lang\n     */\n    if (this.initialized) {\n      lang = active;\n      return lang;\n    }\n    if (provider) {\n      const [, extracted] = getPipeValue(provider, 'static');\n      lang = extracted;\n    }\n    if (inline) {\n      const [, extracted] = getPipeValue(inline, 'static');\n      lang = extracted;\n    }\n    this.initialized = true;\n    return lang;\n  }\n  /**\n   *\n   * Resolve the lang\n   *\n   * @example\n   *\n   * resolveLangBasedOnScope('todos/en') => en\n   * resolveLangBasedOnScope('en') => en\n   *\n   */\n  resolveLangBasedOnScope(lang) {\n    const scope = getScopeFromLang(lang);\n    return scope ? getLangFromScope(lang) : lang;\n  }\n  /**\n   *\n   * Resolve the lang path for loading\n   *\n   * @example\n   *\n   * resolveLangPath('todos', 'en') => todos/en\n   * resolveLangPath('en') => en\n   *\n   */\n  resolveLangPath(lang, scope) {\n    return scope ? `${scope}/${lang}` : lang;\n  }\n}\nclass ScopeResolver {\n  service;\n  constructor(service) {\n    this.service = service;\n  }\n  // inline => provider\n  resolve(params) {\n    const {\n      inline,\n      provider\n    } = params;\n    if (inline) {\n      return inline;\n    }\n    if (provider) {\n      if (isScopeObject(provider)) {\n        const {\n          scope,\n          alias = toCamelCase(scope)\n        } = provider;\n        this.service._setScopeAlias(scope, alias);\n        return scope;\n      }\n      return provider;\n    }\n    return undefined;\n  }\n}\nclass TranslocoDirective {\n  service = inject(TranslocoService);\n  tpl = inject(TemplateRef, {\n    optional: true\n  });\n  providerLang = inject(TRANSLOCO_LANG, {\n    optional: true\n  });\n  providerScope = inject(TRANSLOCO_SCOPE, {\n    optional: true\n  });\n  providedLoadingTpl = inject(TRANSLOCO_LOADING_TEMPLATE, {\n    optional: true\n  });\n  cdr = inject(ChangeDetectorRef);\n  host = inject(ElementRef);\n  vcr = inject(ViewContainerRef);\n  renderer = inject(Renderer2);\n  subscription = null;\n  view;\n  translationMemo = {};\n  key;\n  params = {};\n  inlineScope;\n  inlineRead;\n  inlineLang;\n  inlineTpl;\n  currentLang;\n  loaderTplHandler;\n  // Whether we already rendered the view once\n  initialized = false;\n  path;\n  langResolver = new LangResolver();\n  scopeResolver = new ScopeResolver(this.service);\n  strategy = this.tpl === null ? 'attribute' : 'structural';\n  static ngTemplateContextGuard(dir, ctx) {\n    return true;\n  }\n  ngOnInit() {\n    const listenToLangChange = shouldListenToLangChanges(this.service, this.providerLang || this.inlineLang);\n    this.subscription = this.service.langChanges$.pipe(switchMap(activeLang => {\n      const lang = this.langResolver.resolve({\n        inline: this.inlineLang,\n        provider: this.providerLang,\n        active: activeLang\n      });\n      return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n    }), listenOrNotOperator(listenToLangChange)).subscribe(() => {\n      this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n      this.strategy === 'attribute' ? this.attributeStrategy() : this.structuralStrategy(this.currentLang, this.inlineRead);\n      this.cdr.markForCheck();\n      this.initialized = true;\n    });\n    if (!this.initialized) {\n      const loadingContent = this.resolveLoadingContent();\n      if (loadingContent) {\n        this.loaderTplHandler = new TemplateHandler(loadingContent, this.vcr);\n        this.loaderTplHandler.attachView();\n      }\n    }\n  }\n  ngOnChanges(changes) {\n    // We need to support dynamic keys/params, so if this is not the first change CD cycle\n    // we need to run the function again in order to update the value\n    if (this.strategy === 'attribute') {\n      const notInit = Object.keys(changes).some(v => !changes[v].firstChange);\n      notInit && this.attributeStrategy();\n    }\n  }\n  attributeStrategy() {\n    this.detachLoader();\n    this.renderer.setProperty(this.host.nativeElement, 'innerText', this.service.translate(this.key, this.params, this.currentLang));\n  }\n  structuralStrategy(lang, read) {\n    this.translationMemo = {};\n    if (this.view) {\n      // when the lang changes we need to change the reference so Angular will update the view\n      this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n      this.view.context['currentLang'] = this.currentLang;\n    } else {\n      this.detachLoader();\n      this.view = this.vcr.createEmbeddedView(this.tpl, {\n        $implicit: this.getTranslateFn(lang, read),\n        currentLang: this.currentLang\n      });\n    }\n  }\n  getTranslateFn(lang, read) {\n    return (key, params) => {\n      const withRead = read ? `${read}.${key}` : key;\n      const withParams = params ? `${withRead}${JSON.stringify(params)}` : withRead;\n      if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {\n        return this.translationMemo[withParams].value;\n      }\n      this.translationMemo[withParams] = {\n        params,\n        value: this.service.translate(withRead, params, lang)\n      };\n      return this.translationMemo[withParams].value;\n    };\n  }\n  resolveLoadingContent() {\n    return this.inlineTpl || this.providedLoadingTpl;\n  }\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n      this.subscription = null;\n    }\n  }\n  detachLoader() {\n    this.loaderTplHandler?.detachView();\n  }\n  resolveScope(lang, providerScope) {\n    const resolvedScope = this.scopeResolver.resolve({\n      inline: this.inlineScope,\n      provider: providerScope\n    });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.service._loadDependencies(this.path, inlineLoader);\n  }\n  static ɵfac = function TranslocoDirective_Factory(t) {\n    return new (t || TranslocoDirective)();\n  };\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TranslocoDirective,\n    selectors: [[\"\", \"transloco\", \"\"]],\n    inputs: {\n      key: [\"transloco\", \"key\"],\n      params: [\"translocoParams\", \"params\"],\n      inlineScope: [\"translocoScope\", \"inlineScope\"],\n      inlineRead: [\"translocoRead\", \"inlineRead\"],\n      inlineLang: [\"translocoLang\", \"inlineLang\"],\n      inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[transloco]',\n      standalone: true\n    }]\n  }], null, {\n    key: [{\n      type: Input,\n      args: ['transloco']\n    }],\n    params: [{\n      type: Input,\n      args: ['translocoParams']\n    }],\n    inlineScope: [{\n      type: Input,\n      args: ['translocoScope']\n    }],\n    inlineRead: [{\n      type: Input,\n      args: ['translocoRead']\n    }],\n    inlineLang: [{\n      type: Input,\n      args: ['translocoLang']\n    }],\n    inlineTpl: [{\n      type: Input,\n      args: ['translocoLoadingTpl']\n    }]\n  });\n})();\nclass TranslocoPipe {\n  service;\n  providerScope;\n  providerLang;\n  cdr;\n  subscription = null;\n  lastValue = '';\n  lastKey;\n  path;\n  langResolver = new LangResolver();\n  scopeResolver;\n  constructor(service, providerScope, providerLang, cdr) {\n    this.service = service;\n    this.providerScope = providerScope;\n    this.providerLang = providerLang;\n    this.cdr = cdr;\n    this.scopeResolver = new ScopeResolver(this.service);\n  }\n  // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n  // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488\n  transform(key, params, inlineLang) {\n    if (!key) {\n      return key;\n    }\n    const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n    if (keyName === this.lastKey) {\n      return this.lastValue;\n    }\n    this.lastKey = keyName;\n    this.subscription?.unsubscribe();\n    const listenToLangChange = shouldListenToLangChanges(this.service, this.providerLang || inlineLang);\n    this.subscription = this.service.langChanges$.pipe(switchMap(activeLang => {\n      const lang = this.langResolver.resolve({\n        inline: inlineLang,\n        provider: this.providerLang,\n        active: activeLang\n      });\n      return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n    }), listenOrNotOperator(listenToLangChange)).subscribe(() => this.updateValue(key, params));\n    return this.lastValue;\n  }\n  ngOnDestroy() {\n    this.subscription?.unsubscribe();\n    // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n    // callback within its `destination` property, preventing classes from being GC'd.\n    this.subscription = null;\n  }\n  updateValue(key, params) {\n    const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n    this.lastValue = this.service.translate(key, params, lang);\n    this.cdr.markForCheck();\n  }\n  resolveScope(lang, providerScope) {\n    const resolvedScope = this.scopeResolver.resolve({\n      inline: undefined,\n      provider: providerScope\n    });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.service._loadDependencies(this.path, inlineLoader);\n  }\n  static ɵfac = function TranslocoPipe_Factory(t) {\n    return new (t || TranslocoPipe)(i0.ɵɵdirectiveInject(TranslocoService, 16), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 24), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 24), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16));\n  };\n  static ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"transloco\",\n    type: TranslocoPipe,\n    pure: false,\n    standalone: true\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'transloco',\n      pure: false,\n      standalone: true\n    }]\n  }], function () {\n    return [{\n      type: TranslocoService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_SCOPE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LANG]\n      }]\n    }, {\n      type: i0.ChangeDetectorRef\n    }];\n  }, null);\n})();\nconst decl = [TranslocoDirective, TranslocoPipe];\nclass TranslocoModule {\n  static ɵfac = function TranslocoModule_Factory(t) {\n    return new (t || TranslocoModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TranslocoModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoModule, [{\n    type: NgModule,\n    args: [{\n      imports: decl,\n      exports: decl\n    }]\n  }], null, null);\n})();\nfunction provideTransloco(options) {\n  const providers = [provideTranslocoTranspiler(DefaultTranspiler), provideTranslocoMissingHandler(DefaultHandler), provideTranslocoInterceptor(DefaultInterceptor), provideTranslocoFallbackStrategy(DefaultFallbackStrategy)];\n  if (options.config) {\n    providers.push(provideTranslocoConfig(options.config));\n  }\n  if (options.loader) {\n    providers.push(provideTranslocoLoader(options.loader));\n  }\n  return providers;\n}\nfunction provideTranslocoConfig(config) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_CONFIG,\n    useValue: translocoConfig(config)\n  }]);\n}\nfunction provideTranslocoLoader(loader) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_LOADER,\n    useClass: loader\n  }]);\n}\nfunction provideTranslocoScope(scope) {\n  return {\n    provide: TRANSLOCO_SCOPE,\n    useValue: scope,\n    multi: true\n  };\n}\nfunction provideTranslocoLoadingTpl(content) {\n  return {\n    provide: TRANSLOCO_LOADING_TEMPLATE,\n    useValue: content\n  };\n}\nfunction provideTranslocoTranspiler(transpiler) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_TRANSPILER,\n    useClass: transpiler,\n    deps: [TRANSLOCO_CONFIG]\n  }]);\n}\nfunction provideTranslocoFallbackStrategy(strategy) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_FALLBACK_STRATEGY,\n    useClass: strategy,\n    deps: [TRANSLOCO_CONFIG]\n  }]);\n}\nfunction provideTranslocoMissingHandler(handler) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_MISSING_HANDLER,\n    useClass: handler\n  }]);\n}\nfunction provideTranslocoInterceptor(interceptor) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_INTERCEPTOR,\n    useClass: interceptor\n  }]);\n}\nfunction provideTranslocoLang(lang) {\n  return {\n    provide: TRANSLOCO_LANG,\n    useValue: lang\n  };\n}\nconst TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\nclass TestingLoader {\n  langs;\n  constructor(langs) {\n    this.langs = langs;\n  }\n  getTranslation(lang) {\n    return of(this.langs[lang]);\n  }\n  static ɵfac = function TestingLoader_Factory(t) {\n    return new (t || TestingLoader)(i0.ɵɵinject(TRANSLOCO_TEST_LANGS));\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TestingLoader,\n    factory: TestingLoader.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TestingLoader, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_TEST_LANGS]\n      }]\n    }];\n  }, null);\n})();\nfunction initTranslocoService(service, langs = {}, options) {\n  const preloadAllLangs = () => options.preloadLangs ? Promise.all(Object.keys(langs).map(lang => service.load(lang).toPromise())) : Promise.resolve();\n  return preloadAllLangs;\n}\nclass TranslocoTestingModule {\n  static forRoot(options) {\n    return {\n      ngModule: TranslocoTestingModule,\n      providers: [provideTransloco({\n        loader: TestingLoader,\n        config: {\n          prodMode: true,\n          missingHandler: {\n            logMissingKey: false\n          },\n          ...options.translocoConfig\n        }\n      }), {\n        provide: TRANSLOCO_TEST_LANGS,\n        useValue: options.langs\n      }, {\n        provide: TRANSLOCO_TEST_OPTIONS,\n        useValue: options\n      }, {\n        provide: APP_INITIALIZER,\n        useFactory: initTranslocoService,\n        deps: [TranslocoService, TRANSLOCO_TEST_LANGS, TRANSLOCO_TEST_OPTIONS],\n        multi: true\n      }]\n    };\n  }\n  static ɵfac = function TranslocoTestingModule_Factory(t) {\n    return new (t || TranslocoTestingModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TranslocoTestingModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [TranslocoModule]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoTestingModule, [{\n    type: NgModule,\n    args: [{\n      exports: [TranslocoModule]\n    }]\n  }], null, null);\n})();\n\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\nfunction getBrowserLang() {\n  let browserLang = getBrowserCultureLang();\n  if (!browserLang || !isBrowser()) {\n    return undefined;\n  }\n  if (browserLang.indexOf('-') !== -1) {\n    browserLang = browserLang.split('-')[0];\n  }\n  if (browserLang.indexOf('_') !== -1) {\n    browserLang = browserLang.split('_')[0];\n  }\n  return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\nfunction getBrowserCultureLang() {\n  if (!isBrowser()) {\n    return '';\n  }\n  const navigator = window.navigator;\n  return navigator.languages?.[0] ?? navigator.language;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DefaultFallbackStrategy, DefaultTranspiler, FunctionalTranspiler, TRANSLOCO_CONFIG, TRANSLOCO_FALLBACK_STRATEGY, TRANSLOCO_INTERCEPTOR, TRANSLOCO_LANG, TRANSLOCO_LOADER, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_MISSING_HANDLER, TRANSLOCO_SCOPE, TRANSLOCO_TRANSPILER, TestingLoader, TranslocoDirective, TranslocoModule, TranslocoPipe, TranslocoService, TranslocoTestingModule, coerceArray, defaultConfig, flatten, getBrowserCultureLang, getBrowserLang, getFunctionArgs, getLangFromScope, getPipeValue, getScopeFromLang, getValue, hasInlineLoader, isBrowser, isDefined, isEmpty, isFunction, isNil, isNumber, isObject, isScopeArray, isScopeObject, isString, provideTransloco, provideTranslocoConfig, provideTranslocoFallbackStrategy, provideTranslocoInterceptor, provideTranslocoLang, provideTranslocoLoader, provideTranslocoLoadingTpl, provideTranslocoMissingHandler, provideTranslocoScope, provideTranslocoTranspiler, setValue, size, toCamelCase, toNumber, translate, translateObject, translocoConfig, unflatten };","map":{"version":3,"names":["i0","InjectionToken","Injectable","Optional","Inject","Component","Input","TemplateRef","inject","ChangeDetectorRef","ElementRef","ViewContainerRef","Renderer2","Directive","Pipe","NgModule","makeEnvironmentProviders","APP_INITIALIZER","of","take","from","map","Subject","BehaviorSubject","forkJoin","retry","tap","catchError","shareReplay","switchMap","combineLatest","EMPTY","unflatten","unflatten$1","flatten","flatten$1","DefaultLoader","translations","constructor","getTranslation","lang","get","TRANSLOCO_LOADER","getValue","obj","path","Object","prototype","hasOwnProperty","call","split","reduce","p","c","setValue","prop","val","lastIndex","length","acc","part","index","Array","isArray","slice","size","collection","isObject","keys","isEmpty","isFunction","isString","isNumber","item","coerceArray","value","toCamelCase","str","replace","word","toLowerCase","toUpperCase","isBrowser","window","isNil","undefined","isDefined","toNumber","isNaN","Number","parseFloat","isScopeObject","scope","isScopeArray","every","hasInlineLoader","loader","safe","TRANSLOCO_CONFIG","providedIn","factory","defaultConfig","defaultLang","reRenderOnLangChange","prodMode","failedRetries","fallbackLang","availableLangs","missingHandler","logMissingKey","useFallbackTranslation","allowEmpty","aot","interpolation","translocoConfig","config","TRANSLOCO_TRANSPILER","DefaultTranspiler","interpolationMatcher","resolveMatcher","transpile","params","translation","key","_","match","trim","handleObject","handleArray","result","forEach","v","getParams","transpiled","ɵfac","DefaultTranspiler_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","ngDevMode","ɵsetClassMetadata","type","decorators","args","start","end","RegExp","getFunctionArgs","argsString","splitted","i","push","FunctionalTranspiler","injector","functionName","func","e","message","includes","Error","FunctionalTranspiler_Factory","Injector","TRANSLOCO_MISSING_HANDLER","DefaultHandler","handle","msg","console","warn","DefaultHandler_Factory","TRANSLOCO_INTERCEPTOR","DefaultInterceptor","preSaveTranslation","preSaveTranslationKey","DefaultInterceptor_Factory","TRANSLOCO_FALLBACK_STRATEGY","DefaultFallbackStrategy","userConfig","getNextLangs","DefaultFallbackStrategy_Factory","getScopeFromLang","pop","join","getLangFromScope","getPipeValue","char","lastItem","toString","shouldListenToLangChanges","service","hasStatic","listenOrNotOperator","listenToLangChange","source","prependScope","inlineLoader","resolveInlineLoader","providerScope","getEventPayload","langName","resolveLoader","options","mainLoader","data","pathLoader","then","res","default","getFallbacksLoaders","fallbackPath","paths","pipe","translate","translateObject","TranslocoService","parser","interceptor","fallbackStrategy","langChanges$","subscription","Map","cache","firstFallbackLang","isResolvedMissingOnce","failedLangs","Set","events","events$","asObservable","JSON","parse","stringify","setAvailableLangs","setFallbackLangForMissingTranslation","setDefaultLang","getDefaultLang","subscribe","wasFailure","setActiveLang","payload","getActiveLang","onLangChanged","next","langs","getAvailableLangs","load","cached","loadTranslation","isScope","_isLangScoped","loadersOptions","fallback","loaders","load$","handleSuccess","set","error","handleFailure","resolveLang","resolveLangAndScope","k","_handleMissingKey","selectTranslate","_isObject","isLang","isScopeWithLang","getObjectByKey","_key","_params","getEntries","selectTranslateObject","firstKey","firstParams","rest","langOrScope","selectTranslation","language$","scopeLangSpecified","currentLang","language","setTranslation","defaults","merge","emitChange","mergedOptions","flattenScopeOrTranslation","getMappedScope","mergedTranslation","flattenTranslation","withHook","setTranslationKey","newValue","fallbackValue","getMissingHandlerData","getAvailableLangsIds","indexOf","_loadDependencies","mainLang","isLoadedTranslation","_completeScopeWithLang","_setScopeAlias","alias","scopeMapping","ngOnDestroy","unsubscribe","clear","first","l","id","activeLang","delete","loadOptions","failedCounter","fallbackLangs","fallbacks","nextLang","add","has","isFallbackLang","langFromScope","hasLang","prefix","currentKey","startsWith","entries","TranslocoService_Factory","TranslocoLoaderComponent","html","TranslocoLoaderComponent_Factory","ɵcmp","ɵɵdefineComponent","selectors","inputs","standalone","features","ɵɵStandaloneFeature","decls","vars","consts","template","TranslocoLoaderComponent_Template","rf","ctx","ɵɵelement","ɵɵproperty","ɵɵsanitizeHtml","encapsulation","TemplateHandler","view","vcr","attachView","createEmbeddedView","componentRef","createComponent","instance","hostView","detectChanges","detachView","TRANSLOCO_LANG","TRANSLOCO_LOADING_TEMPLATE","TRANSLOCO_SCOPE","LangResolver","initialized","resolve","inline","provider","active","extracted","resolveLangBasedOnScope","resolveLangPath","ScopeResolver","TranslocoDirective","tpl","optional","providerLang","providedLoadingTpl","cdr","host","renderer","translationMemo","inlineScope","inlineRead","inlineLang","inlineTpl","loaderTplHandler","langResolver","scopeResolver","strategy","ngTemplateContextGuard","dir","ngOnInit","resolveScope","attributeStrategy","structuralStrategy","markForCheck","loadingContent","resolveLoadingContent","ngOnChanges","changes","notInit","some","firstChange","detachLoader","setProperty","nativeElement","read","context","getTranslateFn","$implicit","withRead","withParams","resolvedScope","TranslocoDirective_Factory","ɵdir","ɵɵdefineDirective","ɵɵNgOnChangesFeature","selector","TranslocoPipe","lastValue","lastKey","transform","keyName","updateValue","TranslocoPipe_Factory","ɵɵdirectiveInject","ɵpipe","ɵɵdefinePipe","name","pure","decl","TranslocoModule","TranslocoModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","exports","provideTransloco","providers","provideTranslocoTranspiler","provideTranslocoMissingHandler","provideTranslocoInterceptor","provideTranslocoFallbackStrategy","provideTranslocoConfig","provideTranslocoLoader","provide","useValue","useClass","provideTranslocoScope","multi","provideTranslocoLoadingTpl","content","transpiler","deps","handler","provideTranslocoLang","TRANSLOCO_TEST_LANGS","TRANSLOCO_TEST_OPTIONS","TestingLoader","TestingLoader_Factory","initTranslocoService","preloadAllLangs","preloadLangs","Promise","all","toPromise","TranslocoTestingModule","forRoot","ngModule","useFactory","TranslocoTestingModule_Factory","getBrowserLang","browserLang","getBrowserCultureLang","navigator","languages"],"sources":["/Users/tusharphalke/Documents/Freelancing_Work/rrms_frontend/node_modules/@ngneat/transloco/fesm2022/ngneat-transloco.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Component, Input, TemplateRef, inject, ChangeDetectorRef, ElementRef, ViewContainerRef, Renderer2, Directive, Pipe, NgModule, makeEnvironmentProviders, APP_INITIALIZER } from '@angular/core';\nimport { of, take, from, map, Subject, BehaviorSubject, forkJoin, retry, tap, catchError, shareReplay, switchMap, combineLatest, EMPTY } from 'rxjs';\nimport { unflatten as unflatten$1, flatten as flatten$1 } from 'flat';\n\nclass DefaultLoader {\n    translations;\n    constructor(translations) {\n        this.translations = translations;\n    }\n    getTranslation(lang) {\n        return of(this.translations.get(lang) || {});\n    }\n}\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\n\nfunction getValue(obj, path) {\n    if (!obj) {\n        return obj;\n    }\n    /* For cases where the key is like: 'general.something.thing' */\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n        return obj[path];\n    }\n    return path.split('.').reduce((p, c) => p?.[c], obj);\n}\nfunction setValue(obj, prop, val) {\n    obj = { ...obj };\n    const split = prop.split('.');\n    const lastIndex = split.length - 1;\n    split.reduce((acc, part, index) => {\n        if (index === lastIndex) {\n            acc[part] = val;\n        }\n        else {\n            acc[part] = Array.isArray(acc[part])\n                ? acc[part].slice()\n                : { ...acc[part] };\n        }\n        return acc && acc[part];\n    }, obj);\n    return obj;\n}\nfunction size(collection) {\n    if (!collection) {\n        return 0;\n    }\n    if (Array.isArray(collection)) {\n        return collection.length;\n    }\n    if (isObject(collection)) {\n        return Object.keys(collection).length;\n    }\n    return collection ? collection.length : 0;\n}\nfunction isEmpty(collection) {\n    return size(collection) === 0;\n}\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\nfunction isString(val) {\n    return typeof val === 'string';\n}\nfunction isNumber(val) {\n    return typeof val === 'number';\n}\nfunction isObject(item) {\n    return !!item && typeof item === 'object' && !Array.isArray(item);\n}\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\nfunction toCamelCase(str) {\n    return str\n        .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => index == 0 ? word.toLowerCase() : word.toUpperCase())\n        .replace(/\\s+|_|-|\\//g, '');\n}\nfunction isBrowser() {\n    return typeof window !== 'undefined';\n}\nfunction isNil(value) {\n    return value === null || value === undefined;\n}\nfunction isDefined(value) {\n    return isNil(value) === false;\n}\nfunction toNumber(value) {\n    if (isNumber(value))\n        return value;\n    if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n        return Number(value);\n    }\n    return null;\n}\nfunction isScopeObject(item) {\n    return item && typeof item.scope === 'string';\n}\nfunction isScopeArray(item) {\n    return Array.isArray(item) && item.every(isScopeObject);\n}\nfunction hasInlineLoader(item) {\n    return item && isObject(item.loader);\n}\nfunction unflatten(obj) {\n    return unflatten$1(obj);\n}\nfunction flatten(obj) {\n    return flatten$1(obj, { safe: true });\n}\n\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n    providedIn: 'root',\n    factory: () => defaultConfig,\n});\nconst defaultConfig = {\n    defaultLang: 'en',\n    reRenderOnLangChange: false,\n    prodMode: false,\n    failedRetries: 2,\n    fallbackLang: [],\n    availableLangs: [],\n    missingHandler: {\n        logMissingKey: true,\n        useFallbackTranslation: false,\n        allowEmpty: false,\n    },\n    flatten: {\n        aot: false,\n    },\n    interpolation: ['{{', '}}'],\n};\nfunction translocoConfig(config = {}) {\n    return {\n        ...defaultConfig,\n        ...config,\n        missingHandler: {\n            ...defaultConfig.missingHandler,\n            ...config.missingHandler,\n        },\n        flatten: {\n            ...defaultConfig.flatten,\n            ...config.flatten,\n        },\n    };\n}\n\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\nclass DefaultTranspiler {\n    interpolationMatcher;\n    constructor(config) {\n        this.interpolationMatcher = resolveMatcher(config ?? defaultConfig);\n    }\n    transpile(value, params = {}, translation, key) {\n        if (isString(value)) {\n            return value.replace(this.interpolationMatcher, (_, match) => {\n                match = match.trim();\n                if (isDefined(params[match])) {\n                    return params[match];\n                }\n                return isDefined(translation[match])\n                    ? this.transpile(translation[match], params, translation, key)\n                    : '';\n            });\n        }\n        else if (params) {\n            if (isObject(value)) {\n                value = this.handleObject(value, params, translation, key);\n            }\n            else if (Array.isArray(value)) {\n                value = this.handleArray(value, params, translation, key);\n            }\n        }\n        return value;\n    }\n    /**\n     *\n     * @example\n     *\n     * const en = {\n     *  a: {\n     *    b: {\n     *      c: \"Hello {{ value }}\"\n     *    }\n     *  }\n     * }\n     *\n     * const params =  {\n     *  \"b.c\": { value: \"Transloco \"}\n     * }\n     *\n     * service.selectTranslate('a', params);\n     *\n     * // the first param will be the result of `en.a`.\n     * // the second param will be `params`.\n     * parser.transpile(value, params, {});\n     *\n     *\n     */\n    handleObject(value, params = {}, translation, key) {\n        let result = value;\n        Object.keys(params).forEach((p) => {\n            // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n            const v = getValue(result, p);\n            // get the params of \"b.c\" => { value: \"Transloco\" }\n            const getParams = getValue(params, p);\n            // transpile the value => \"Hello Transloco\"\n            const transpiled = this.transpile(v, getParams, translation, key);\n            // set \"b.c\" to `transpiled`\n            result = setValue(result, p, transpiled);\n        });\n        return result;\n    }\n    handleArray(value, params = {}, translation, key) {\n        return value.map((v) => this.transpile(v, params, translation, key));\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultTranspiler, deps: [{ token: TRANSLOCO_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultTranspiler });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultTranspiler, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }]; } });\nfunction resolveMatcher(config) {\n    const [start, end] = config.interpolation;\n    return new RegExp(`${start}(.*?)${end}`, 'g');\n}\nfunction getFunctionArgs(argsString) {\n    const splitted = argsString ? argsString.split(',') : [];\n    const args = [];\n    for (let i = 0; i < splitted.length; i++) {\n        let value = splitted[i].trim();\n        while (value[value.length - 1] === '\\\\') {\n            i++;\n            value = value.replace('\\\\', ',') + splitted[i];\n        }\n        args.push(value);\n    }\n    return args;\n}\nclass FunctionalTranspiler extends DefaultTranspiler {\n    injector;\n    constructor(injector) {\n        super();\n        this.injector = injector;\n    }\n    transpile(value, params = {}, translation, key) {\n        let transpiled = value;\n        if (isString(value)) {\n            transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*?)\\)\\s*]]/g, (match, functionName, args) => {\n                try {\n                    const func = this.injector.get(functionName);\n                    return func.transpile(...getFunctionArgs(args));\n                }\n                catch (e) {\n                    let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n                    if (e.message.includes('NullInjectorError')) {\n                        message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n                    }\n                    throw new Error(message);\n                }\n            });\n        }\n        return super.transpile(transpiled, params, translation, key);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: FunctionalTranspiler, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: FunctionalTranspiler });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: FunctionalTranspiler, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });\n\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\nclass DefaultHandler {\n    handle(key, config) {\n        if (config.missingHandler.logMissingKey && !config.prodMode) {\n            const msg = `Missing translation for '${key}'`;\n            console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n        }\n        return key;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultHandler });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultHandler, decorators: [{\n            type: Injectable\n        }] });\n\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\nclass DefaultInterceptor {\n    preSaveTranslation(translation) {\n        return translation;\n    }\n    preSaveTranslationKey(_, value) {\n        return value;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultInterceptor, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultInterceptor });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultInterceptor, decorators: [{\n            type: Injectable\n        }] });\n\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\nclass DefaultFallbackStrategy {\n    userConfig;\n    constructor(userConfig) {\n        this.userConfig = userConfig;\n    }\n    getNextLangs() {\n        const fallbackLang = this.userConfig.fallbackLang;\n        if (!fallbackLang) {\n            throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n        }\n        return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultFallbackStrategy, deps: [{ token: TRANSLOCO_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultFallbackStrategy });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: DefaultFallbackStrategy, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }]; } });\n\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\nfunction getScopeFromLang(lang) {\n    if (!lang) {\n        return '';\n    }\n    const split = lang.split('/');\n    split.pop();\n    return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\nfunction getLangFromScope(lang) {\n    if (!lang) {\n        return '';\n    }\n    return lang.split('/').pop();\n}\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\nfunction getPipeValue(str, value, char = '|') {\n    if (isString(str)) {\n        const splitted = str.split(char);\n        const lastItem = splitted.pop();\n        return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n    }\n    return [false, ''];\n}\nfunction shouldListenToLangChanges(service, lang) {\n    const [hasStatic] = getPipeValue(lang, 'static');\n    if (!hasStatic) {\n        // If we didn't get 'lang|static' check if it's set in the global level\n        return !!service.config.reRenderOnLangChange;\n    }\n    // We have 'lang|static' so don't listen to lang changes\n    return false;\n}\nfunction listenOrNotOperator(listenToLangChange) {\n    return listenToLangChange ? (source) => source : take(1);\n}\nfunction prependScope(inlineLoader, scope) {\n    return Object.keys(inlineLoader).reduce((acc, lang) => {\n        acc[`${scope}/${lang}`] = inlineLoader[lang];\n        return acc;\n    }, {});\n}\nfunction resolveInlineLoader(providerScope, scope) {\n    return hasInlineLoader(providerScope)\n        ? prependScope(providerScope.loader, scope)\n        : undefined;\n}\nfunction getEventPayload(lang) {\n    return {\n        scope: getScopeFromLang(lang) || null,\n        langName: getLangFromScope(lang),\n    };\n}\n\nfunction resolveLoader(options) {\n    const { path, inlineLoader, mainLoader, data } = options;\n    if (inlineLoader) {\n        const pathLoader = inlineLoader[path];\n        if (isFunction(pathLoader) === false) {\n            throw `You're using an inline loader but didn't provide a loader for ${path}`;\n        }\n        return inlineLoader[path]().then((res) => res.default ? res.default : res);\n    }\n    return mainLoader.getTranslation(path, data);\n}\n\nfunction getFallbacksLoaders({ mainLoader, path, data, fallbackPath, inlineLoader, }) {\n    const paths = fallbackPath ? [path, fallbackPath] : [path];\n    return paths.map((path) => {\n        const loader = resolveLoader({ path, mainLoader, inlineLoader, data });\n        return from(loader).pipe(map((translation) => ({\n            translation,\n            lang: path,\n        })));\n    });\n}\n\nlet service;\nfunction translate(key, params = {}, lang) {\n    return service.translate(key, params, lang);\n}\nfunction translateObject(key, params = {}, lang) {\n    return service.translateObject(key, params, lang);\n}\nclass TranslocoService {\n    loader;\n    parser;\n    missingHandler;\n    interceptor;\n    fallbackStrategy;\n    langChanges$;\n    subscription = null;\n    translations = new Map();\n    cache = new Map();\n    firstFallbackLang;\n    defaultLang = '';\n    availableLangs = [];\n    isResolvedMissingOnce = false;\n    lang;\n    failedLangs = new Set();\n    events = new Subject();\n    events$ = this.events.asObservable();\n    config;\n    constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n        this.loader = loader;\n        this.parser = parser;\n        this.missingHandler = missingHandler;\n        this.interceptor = interceptor;\n        this.fallbackStrategy = fallbackStrategy;\n        if (!this.loader) {\n            this.loader = new DefaultLoader(this.translations);\n        }\n        service = this;\n        this.config = JSON.parse(JSON.stringify(userConfig));\n        this.setAvailableLangs(this.config.availableLangs || []);\n        this.setFallbackLangForMissingTranslation(this.config);\n        this.setDefaultLang(this.config.defaultLang);\n        this.lang = new BehaviorSubject(this.getDefaultLang());\n        // Don't use distinctUntilChanged as we need the ability to update\n        // the value when using setTranslation or setTranslationKeys\n        this.langChanges$ = this.lang.asObservable();\n        /**\n         * When we have a failure, we want to define the next language that succeeded as the active\n         */\n        this.subscription = this.events$.subscribe((e) => {\n            if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n                this.setActiveLang(e.payload.langName);\n            }\n        });\n    }\n    getDefaultLang() {\n        return this.defaultLang;\n    }\n    setDefaultLang(lang) {\n        this.defaultLang = lang;\n    }\n    getActiveLang() {\n        return this.lang.getValue();\n    }\n    setActiveLang(lang) {\n        this.parser.onLangChanged?.(lang);\n        this.lang.next(lang);\n        this.events.next({\n            type: 'langChanged',\n            payload: getEventPayload(lang),\n        });\n        return this;\n    }\n    setAvailableLangs(langs) {\n        this.availableLangs = langs;\n    }\n    /**\n     * Gets the available languages.\n     *\n     * @returns\n     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n     * depending on how the available languages are set in your module.\n     */\n    getAvailableLangs() {\n        return this.availableLangs;\n    }\n    load(path, options = {}) {\n        const cached = this.cache.get(path);\n        if (cached) {\n            return cached;\n        }\n        let loadTranslation;\n        const isScope = this._isLangScoped(path);\n        let scope;\n        if (isScope) {\n            scope = getScopeFromLang(path);\n        }\n        const loadersOptions = {\n            path,\n            mainLoader: this.loader,\n            inlineLoader: options.inlineLoader,\n            data: isScope ? { scope: scope } : undefined,\n        };\n        if (this.useFallbackTranslation(path)) {\n            // if the path is scope the fallback should be `scope/fallbackLang`;\n            const fallback = isScope\n                ? `${scope}/${this.firstFallbackLang}`\n                : this.firstFallbackLang;\n            const loaders = getFallbacksLoaders({\n                ...loadersOptions,\n                fallbackPath: fallback,\n            });\n            loadTranslation = forkJoin(loaders);\n        }\n        else {\n            const loader = resolveLoader(loadersOptions);\n            loadTranslation = from(loader);\n        }\n        const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap((translation) => {\n            if (Array.isArray(translation)) {\n                translation.forEach((t) => {\n                    this.handleSuccess(t.lang, t.translation);\n                    // Save the fallback in cache so we'll not create a redundant request\n                    if (t.lang !== path) {\n                        this.cache.set(t.lang, of({}));\n                    }\n                });\n                return;\n            }\n            this.handleSuccess(path, translation);\n        }), catchError((error) => {\n            if (!this.config.prodMode) {\n                console.error(`Error while trying to load \"${path}\"`, error);\n            }\n            return this.handleFailure(path, options);\n        }), shareReplay(1));\n        this.cache.set(path, load$);\n        return load$;\n    }\n    /**\n     * Gets the instant translated value of a key\n     *\n     * @example\n     *\n     * translate<string>('hello')\n     * translate('hello', { value: 'value' })\n     * translate<string[]>(['hello', 'key'])\n     * translate('hello', { }, 'en')\n     * translate('scope.someKey', { }, 'en')\n     */\n    translate(key, params = {}, lang = this.getActiveLang()) {\n        if (!key)\n            return key;\n        const { scope, resolveLang } = this.resolveLangAndScope(lang);\n        if (Array.isArray(key)) {\n            return key.map((k) => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang));\n        }\n        key = scope ? `${scope}.${key}` : key;\n        const translation = this.getTranslation(resolveLang);\n        const value = translation[key];\n        if (!value) {\n            return this._handleMissingKey(key, value, params);\n        }\n        return this.parser.transpile(value, params, translation, key);\n    }\n    /**\n     * Gets the translated value of a key as observable\n     *\n     * @example\n     *\n     * selectTranslate<string>('hello').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n     *\n     */\n    selectTranslate(key, params, lang, _isObject = false) {\n        let inlineLoader;\n        const load = (lang, options) => this.load(lang, options).pipe(map(() => _isObject\n            ? this.translateObject(key, params, lang)\n            : this.translate(key, params, lang)));\n        if (isNil(lang)) {\n            return this.langChanges$.pipe(switchMap((lang) => load(lang)));\n        }\n        if (isScopeArray(lang) || isScopeObject(lang)) {\n            // it's a scope object.\n            const providerScope = Array.isArray(lang) ? lang[0] : lang;\n            lang = providerScope.scope;\n            inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n        }\n        lang = lang;\n        if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n            return load(lang);\n        }\n        // it's a scope\n        const scope = lang;\n        return this.langChanges$.pipe(switchMap((lang) => load(`${scope}/${lang}`, { inlineLoader })));\n    }\n    /**\n     * Whether the scope with lang\n     *\n     * @example\n     *\n     * todos/en => true\n     * todos => false\n     */\n    isScopeWithLang(lang) {\n        return this.isLang(getLangFromScope(lang));\n    }\n    translateObject(key, params = {}, lang = this.getActiveLang()) {\n        if (isString(key) || Array.isArray(key)) {\n            const { resolveLang, scope } = this.resolveLangAndScope(lang);\n            if (Array.isArray(key)) {\n                return key.map((k) => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang));\n            }\n            const translation = this.getTranslation(resolveLang);\n            key = scope ? `${scope}.${key}` : key;\n            const value = unflatten(this.getObjectByKey(translation, key));\n            /* If an empty object was returned we want to try and translate the key as a string and not an object */\n            return isEmpty(value)\n                ? this.translate(key, params, lang)\n                : this.parser.transpile(value, params, translation, key);\n        }\n        const translations = [];\n        for (const [_key, _params] of this.getEntries(key)) {\n            translations.push(this.translateObject(_key, _params, lang));\n        }\n        return translations;\n    }\n    selectTranslateObject(key, params, lang) {\n        if (isString(key) || Array.isArray(key)) {\n            return this.selectTranslate(key, params, lang, true);\n        }\n        const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n        /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n         * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n        return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map((value) => {\n            const translations = [value];\n            for (const [_key, _params] of rest) {\n                translations.push(this.translateObject(_key, _params, lang));\n            }\n            return translations;\n        }));\n    }\n    getTranslation(langOrScope) {\n        if (langOrScope) {\n            if (this.isLang(langOrScope)) {\n                return this.translations.get(langOrScope) || {};\n            }\n            else {\n                // This is a scope, build the scope value from the translation object\n                const { scope, resolveLang } = this.resolveLangAndScope(langOrScope);\n                const translation = this.translations.get(resolveLang) || {};\n                return this.getObjectByKey(translation, scope);\n            }\n        }\n        return this.translations;\n    }\n    /**\n     * Gets an object of translations for a given language\n     *\n     * @example\n     *\n     * selectTranslation().subscribe() - will return the current lang translation\n     * selectTranslation('es').subscribe()\n     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n     * selectTranslation('admin-page/es').subscribe()\n     */\n    selectTranslation(lang) {\n        let language$ = this.langChanges$;\n        if (lang) {\n            const scopeLangSpecified = getLangFromScope(lang) !== lang;\n            if (this.isLang(lang) || scopeLangSpecified) {\n                language$ = of(lang);\n            }\n            else {\n                language$ = this.langChanges$.pipe(map((currentLang) => `${lang}/${currentLang}`));\n            }\n        }\n        return language$.pipe(switchMap((language) => this.load(language).pipe(map(() => this.getTranslation(language)))));\n    }\n    /**\n     * Sets or merge a given translation object to current lang\n     *\n     * @example\n     *\n     * setTranslation({ ... })\n     * setTranslation({ ... }, 'en')\n     * setTranslation({ ... }, 'es', { merge: false } )\n     * setTranslation({ ... }, 'todos/en', { merge: false } )\n     */\n    setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n        const defaults = { merge: true, emitChange: true };\n        const mergedOptions = { ...defaults, ...options };\n        const scope = getScopeFromLang(lang);\n        /**\n         * If this isn't a scope we use the whole translation as is\n         * otherwise we need to flat the scope and use it\n         */\n        let flattenScopeOrTranslation = translation;\n        // Merged the scoped language into the active language\n        if (scope) {\n            const key = this.getMappedScope(scope);\n            flattenScopeOrTranslation = flatten({ [key]: translation });\n        }\n        const currentLang = scope ? getLangFromScope(lang) : lang;\n        const mergedTranslation = {\n            ...(mergedOptions.merge && this.getTranslation(currentLang)),\n            ...flattenScopeOrTranslation,\n        };\n        const flattenTranslation = this.config.flatten.aot\n            ? mergedTranslation\n            : flatten(mergedTranslation);\n        const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n        this.translations.set(currentLang, withHook);\n        mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n    }\n    /**\n     * Sets translation key with given value\n     *\n     * @example\n     *\n     * setTranslationKey('key', 'value')\n     * setTranslationKey('key.nested', 'value')\n     * setTranslationKey('key.nested', 'value', 'en')\n     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n     */\n    setTranslationKey(key, value, \n    // Todo: Add the lang to the options in v3\n    lang = this.getActiveLang(), options = {}) {\n        const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n        const newValue = {\n            [key]: withHook,\n        };\n        this.setTranslation(newValue, lang, { ...options, merge: true });\n    }\n    /**\n     * Sets the fallback lang for the currently active language\n     * @param fallbackLang\n     */\n    setFallbackLangForMissingTranslation({ fallbackLang, }) {\n        const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n        if (fallbackLang && this.useFallbackTranslation(lang)) {\n            this.firstFallbackLang = lang;\n        }\n    }\n    /**\n     * @internal\n     */\n    _handleMissingKey(key, value, params) {\n        if (this.config.missingHandler.allowEmpty && value === '') {\n            return '';\n        }\n        if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {\n            // We need to set it to true to prevent a loop\n            this.isResolvedMissingOnce = true;\n            const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n            this.isResolvedMissingOnce = false;\n            return fallbackValue;\n        }\n        return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n    }\n    /**\n     * @internal\n     */\n    _isLangScoped(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) === -1;\n    }\n    /**\n     * Checks if a given string is one of the specified available languages.\n     * @returns\n     * True if the given string is an available language.\n     * False if the given string is not an available language.\n     */\n    isLang(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) !== -1;\n    }\n    /**\n     * @internal\n     *\n     * We always want to make sure the global lang is loaded\n     * before loading the scope since you can access both via the pipe/directive.\n     */\n    _loadDependencies(path, inlineLoader) {\n        const mainLang = getLangFromScope(path);\n        if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n            return combineLatest([\n                this.load(mainLang),\n                this.load(path, { inlineLoader }),\n            ]);\n        }\n        return this.load(path, { inlineLoader });\n    }\n    /**\n     * @internal\n     */\n    _completeScopeWithLang(langOrScope) {\n        if (this._isLangScoped(langOrScope) &&\n            !this.isLang(getLangFromScope(langOrScope))) {\n            return `${langOrScope}/${this.getActiveLang()}`;\n        }\n        return langOrScope;\n    }\n    /**\n     * @internal\n     */\n    _setScopeAlias(scope, alias) {\n        if (!this.config.scopeMapping) {\n            this.config.scopeMapping = {};\n        }\n        this.config.scopeMapping[scope] = alias;\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n            // callback within its `destination` property, preventing classes from being GC'd.\n            this.subscription = null;\n        }\n        // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.\n        // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from\n        // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created\n        // and destroyed per each HTTP request, but any service is not getting GC'd.\n        this.cache.clear();\n    }\n    isLoadedTranslation(lang) {\n        return size(this.getTranslation(lang));\n    }\n    getAvailableLangsIds() {\n        const first = this.getAvailableLangs()[0];\n        if (isString(first)) {\n            return this.getAvailableLangs();\n        }\n        return this.getAvailableLangs().map((l) => l.id);\n    }\n    getMissingHandlerData() {\n        return {\n            ...this.config,\n            activeLang: this.getActiveLang(),\n            availableLangs: this.availableLangs,\n            defaultLang: this.defaultLang,\n        };\n    }\n    /**\n     * Use a fallback translation set for missing keys of the primary language\n     * This is unrelated to the fallback language (which changes the active language)\n     */\n    useFallbackTranslation(lang) {\n        return (this.config.missingHandler.useFallbackTranslation &&\n            lang !== this.firstFallbackLang);\n    }\n    handleSuccess(lang, translation) {\n        this.setTranslation(translation, lang, { emitChange: false });\n        this.events.next({\n            wasFailure: !!this.failedLangs.size,\n            type: 'translationLoadSuccess',\n            payload: getEventPayload(lang),\n        });\n        this.failedLangs.forEach((l) => this.cache.delete(l));\n        this.failedLangs.clear();\n    }\n    handleFailure(lang, loadOptions) {\n        // When starting to load a first choice language, initialize\n        // the failed counter and resolve the fallback langs.\n        if (isNil(loadOptions.failedCounter)) {\n            loadOptions.failedCounter = 0;\n            if (!loadOptions.fallbackLangs) {\n                loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n            }\n        }\n        const splitted = lang.split('/');\n        const fallbacks = loadOptions.fallbackLangs;\n        const nextLang = fallbacks[loadOptions.failedCounter];\n        this.failedLangs.add(lang);\n        // This handles the case where a loaded fallback language is requested again\n        if (this.cache.has(nextLang)) {\n            this.handleSuccess(nextLang, this.getTranslation(nextLang));\n            return EMPTY;\n        }\n        const isFallbackLang = nextLang === splitted[splitted.length - 1];\n        if (!nextLang || isFallbackLang) {\n            let msg = `Unable to load translation and all the fallback languages`;\n            if (splitted.length > 1) {\n                msg += `, did you misspelled the scope name?`;\n            }\n            throw new Error(msg);\n        }\n        let resolveLang = nextLang;\n        // if it's scoped lang\n        if (splitted.length > 1) {\n            // We need to resolve it to:\n            // todos/langNotExists => todos/nextLang\n            splitted[splitted.length - 1] = nextLang;\n            resolveLang = splitted.join('/');\n        }\n        loadOptions.failedCounter++;\n        this.events.next({\n            type: 'translationLoadFailure',\n            payload: getEventPayload(lang),\n        });\n        return this.load(resolveLang, loadOptions);\n    }\n    getMappedScope(scope) {\n        const { scopeMapping = {} } = this.config;\n        return scopeMapping[scope] || toCamelCase(scope);\n    }\n    /**\n     * If lang is scope we need to check the following cases:\n     * todos/es => in this case we should take `es` as lang\n     * todos => in this case we should set the active lang as lang\n     */\n    resolveLangAndScope(lang) {\n        let resolveLang = lang;\n        let scope;\n        if (this._isLangScoped(lang)) {\n            // en for example\n            const langFromScope = getLangFromScope(lang);\n            // en is lang\n            const hasLang = this.isLang(langFromScope);\n            // take en\n            resolveLang = hasLang ? langFromScope : this.getActiveLang();\n            // find the scope\n            scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n        }\n        return { scope, resolveLang };\n    }\n    getObjectByKey(translation, key) {\n        const result = {};\n        const prefix = `${key}.`;\n        for (const currentKey in translation) {\n            if (currentKey.startsWith(prefix)) {\n                result[currentKey.replace(prefix, '')] = translation[currentKey];\n            }\n        }\n        return result;\n    }\n    getEntries(key) {\n        return key instanceof Map ? key.entries() : Object.entries(key);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoService, deps: [{ token: TRANSLOCO_LOADER, optional: true }, { token: TRANSLOCO_TRANSPILER }, { token: TRANSLOCO_MISSING_HANDLER }, { token: TRANSLOCO_INTERCEPTOR }, { token: TRANSLOCO_CONFIG }, { token: TRANSLOCO_FALLBACK_STRATEGY }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoService, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LOADER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_TRANSPILER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_MISSING_HANDLER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_INTERCEPTOR]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_FALLBACK_STRATEGY]\n                }] }]; } });\n\nclass TranslocoLoaderComponent {\n    html;\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoLoaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"16.1.7\", type: TranslocoLoaderComponent, isStandalone: true, selector: \"ng-component\", inputs: { html: \"html\" }, ngImport: i0, template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `, isInline: true });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoLoaderComponent, decorators: [{\n            type: Component,\n            args: [{\n                    template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `,\n                    standalone: true,\n                }]\n        }], propDecorators: { html: [{\n                type: Input\n            }] } });\n\nclass TemplateHandler {\n    view;\n    vcr;\n    constructor(view, vcr) {\n        this.view = view;\n        this.vcr = vcr;\n    }\n    attachView() {\n        if (this.view instanceof TemplateRef) {\n            this.vcr.createEmbeddedView(this.view);\n        }\n        else if (isString(this.view)) {\n            const componentRef = this.vcr.createComponent(TranslocoLoaderComponent);\n            componentRef.instance.html = this.view;\n            componentRef.hostView.detectChanges();\n        }\n        else {\n            this.vcr.createComponent(this.view);\n        }\n    }\n    detachView() {\n        this.vcr.clear();\n    }\n}\n\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\n\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\n\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\n\nclass LangResolver {\n    initialized = false;\n    // inline => provider => active\n    resolve({ inline, provider, active }) {\n        let lang = active;\n        /**\n         * When the user changes the lang we need to update\n         * the view. Otherwise, the lang will remain the inline/provided lang\n         */\n        if (this.initialized) {\n            lang = active;\n            return lang;\n        }\n        if (provider) {\n            const [, extracted] = getPipeValue(provider, 'static');\n            lang = extracted;\n        }\n        if (inline) {\n            const [, extracted] = getPipeValue(inline, 'static');\n            lang = extracted;\n        }\n        this.initialized = true;\n        return lang;\n    }\n    /**\n     *\n     * Resolve the lang\n     *\n     * @example\n     *\n     * resolveLangBasedOnScope('todos/en') => en\n     * resolveLangBasedOnScope('en') => en\n     *\n     */\n    resolveLangBasedOnScope(lang) {\n        const scope = getScopeFromLang(lang);\n        return scope ? getLangFromScope(lang) : lang;\n    }\n    /**\n     *\n     * Resolve the lang path for loading\n     *\n     * @example\n     *\n     * resolveLangPath('todos', 'en') => todos/en\n     * resolveLangPath('en') => en\n     *\n     */\n    resolveLangPath(lang, scope) {\n        return scope ? `${scope}/${lang}` : lang;\n    }\n}\n\nclass ScopeResolver {\n    service;\n    constructor(service) {\n        this.service = service;\n    }\n    // inline => provider\n    resolve(params) {\n        const { inline, provider } = params;\n        if (inline) {\n            return inline;\n        }\n        if (provider) {\n            if (isScopeObject(provider)) {\n                const { scope, alias = toCamelCase(scope) } = provider;\n                this.service._setScopeAlias(scope, alias);\n                return scope;\n            }\n            return provider;\n        }\n        return undefined;\n    }\n}\n\nclass TranslocoDirective {\n    service = inject(TranslocoService);\n    tpl = inject(TemplateRef, {\n        optional: true,\n    });\n    providerLang = inject(TRANSLOCO_LANG, { optional: true });\n    providerScope = inject(TRANSLOCO_SCOPE, { optional: true });\n    providedLoadingTpl = inject(TRANSLOCO_LOADING_TEMPLATE, {\n        optional: true,\n    });\n    cdr = inject(ChangeDetectorRef);\n    host = inject(ElementRef);\n    vcr = inject(ViewContainerRef);\n    renderer = inject(Renderer2);\n    subscription = null;\n    view;\n    translationMemo = {};\n    key;\n    params = {};\n    inlineScope;\n    inlineRead;\n    inlineLang;\n    inlineTpl;\n    currentLang;\n    loaderTplHandler;\n    // Whether we already rendered the view once\n    initialized = false;\n    path;\n    langResolver = new LangResolver();\n    scopeResolver = new ScopeResolver(this.service);\n    strategy = this.tpl === null ? 'attribute' : 'structural';\n    static ngTemplateContextGuard(dir, ctx) {\n        return true;\n    }\n    ngOnInit() {\n        const listenToLangChange = shouldListenToLangChanges(this.service, this.providerLang || this.inlineLang);\n        this.subscription = this.service.langChanges$\n            .pipe(switchMap((activeLang) => {\n            const lang = this.langResolver.resolve({\n                inline: this.inlineLang,\n                provider: this.providerLang,\n                active: activeLang,\n            });\n            return Array.isArray(this.providerScope)\n                ? forkJoin(this.providerScope.map((providerScope) => this.resolveScope(lang, providerScope)))\n                : this.resolveScope(lang, this.providerScope);\n        }), listenOrNotOperator(listenToLangChange))\n            .subscribe(() => {\n            this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n            this.strategy === 'attribute'\n                ? this.attributeStrategy()\n                : this.structuralStrategy(this.currentLang, this.inlineRead);\n            this.cdr.markForCheck();\n            this.initialized = true;\n        });\n        if (!this.initialized) {\n            const loadingContent = this.resolveLoadingContent();\n            if (loadingContent) {\n                this.loaderTplHandler = new TemplateHandler(loadingContent, this.vcr);\n                this.loaderTplHandler.attachView();\n            }\n        }\n    }\n    ngOnChanges(changes) {\n        // We need to support dynamic keys/params, so if this is not the first change CD cycle\n        // we need to run the function again in order to update the value\n        if (this.strategy === 'attribute') {\n            const notInit = Object.keys(changes).some((v) => !changes[v].firstChange);\n            notInit && this.attributeStrategy();\n        }\n    }\n    attributeStrategy() {\n        this.detachLoader();\n        this.renderer.setProperty(this.host.nativeElement, 'innerText', this.service.translate(this.key, this.params, this.currentLang));\n    }\n    structuralStrategy(lang, read) {\n        this.translationMemo = {};\n        if (this.view) {\n            // when the lang changes we need to change the reference so Angular will update the view\n            this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n            this.view.context['currentLang'] = this.currentLang;\n        }\n        else {\n            this.detachLoader();\n            this.view = this.vcr.createEmbeddedView(this.tpl, {\n                $implicit: this.getTranslateFn(lang, read),\n                currentLang: this.currentLang,\n            });\n        }\n    }\n    getTranslateFn(lang, read) {\n        return (key, params) => {\n            const withRead = read ? `${read}.${key}` : key;\n            const withParams = params\n                ? `${withRead}${JSON.stringify(params)}`\n                : withRead;\n            if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {\n                return this.translationMemo[withParams].value;\n            }\n            this.translationMemo[withParams] = {\n                params,\n                value: this.service.translate(withRead, params, lang),\n            };\n            return this.translationMemo[withParams].value;\n        };\n    }\n    resolveLoadingContent() {\n        return this.inlineTpl || this.providedLoadingTpl;\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n            // callback within its `destination` property, preventing classes from being GC'd.\n            this.subscription = null;\n        }\n    }\n    detachLoader() {\n        this.loaderTplHandler?.detachView();\n    }\n    resolveScope(lang, providerScope) {\n        const resolvedScope = this.scopeResolver.resolve({\n            inline: this.inlineScope,\n            provider: providerScope,\n        });\n        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n        return this.service._loadDependencies(this.path, inlineLoader);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.1.7\", type: TranslocoDirective, isStandalone: true, selector: \"[transloco]\", inputs: { key: [\"transloco\", \"key\"], params: [\"translocoParams\", \"params\"], inlineScope: [\"translocoScope\", \"inlineScope\"], inlineRead: [\"translocoRead\", \"inlineRead\"], inlineLang: [\"translocoLang\", \"inlineLang\"], inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"] }, usesOnChanges: true, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[transloco]',\n                    standalone: true,\n                }]\n        }], propDecorators: { key: [{\n                type: Input,\n                args: ['transloco']\n            }], params: [{\n                type: Input,\n                args: ['translocoParams']\n            }], inlineScope: [{\n                type: Input,\n                args: ['translocoScope']\n            }], inlineRead: [{\n                type: Input,\n                args: ['translocoRead']\n            }], inlineLang: [{\n                type: Input,\n                args: ['translocoLang']\n            }], inlineTpl: [{\n                type: Input,\n                args: ['translocoLoadingTpl']\n            }] } });\n\nclass TranslocoPipe {\n    service;\n    providerScope;\n    providerLang;\n    cdr;\n    subscription = null;\n    lastValue = '';\n    lastKey;\n    path;\n    langResolver = new LangResolver();\n    scopeResolver;\n    constructor(service, providerScope, providerLang, cdr) {\n        this.service = service;\n        this.providerScope = providerScope;\n        this.providerLang = providerLang;\n        this.cdr = cdr;\n        this.scopeResolver = new ScopeResolver(this.service);\n    }\n    // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488\n    transform(key, params, inlineLang) {\n        if (!key) {\n            return key;\n        }\n        const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n        if (keyName === this.lastKey) {\n            return this.lastValue;\n        }\n        this.lastKey = keyName;\n        this.subscription?.unsubscribe();\n        const listenToLangChange = shouldListenToLangChanges(this.service, this.providerLang || inlineLang);\n        this.subscription = this.service.langChanges$\n            .pipe(switchMap((activeLang) => {\n            const lang = this.langResolver.resolve({\n                inline: inlineLang,\n                provider: this.providerLang,\n                active: activeLang,\n            });\n            return Array.isArray(this.providerScope)\n                ? forkJoin(this.providerScope.map((providerScope) => this.resolveScope(lang, providerScope)))\n                : this.resolveScope(lang, this.providerScope);\n        }), listenOrNotOperator(listenToLangChange))\n            .subscribe(() => this.updateValue(key, params));\n        return this.lastValue;\n    }\n    ngOnDestroy() {\n        this.subscription?.unsubscribe();\n        // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n        // callback within its `destination` property, preventing classes from being GC'd.\n        this.subscription = null;\n    }\n    updateValue(key, params) {\n        const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n        this.lastValue = this.service.translate(key, params, lang);\n        this.cdr.markForCheck();\n    }\n    resolveScope(lang, providerScope) {\n        const resolvedScope = this.scopeResolver.resolve({\n            inline: undefined,\n            provider: providerScope,\n        });\n        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n        return this.service._loadDependencies(this.path, inlineLoader);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoPipe, deps: [{ token: TranslocoService }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Pipe });\n    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: \"14.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoPipe, isStandalone: true, name: \"transloco\", pure: false });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoPipe, decorators: [{\n            type: Pipe,\n            args: [{\n                    name: 'transloco',\n                    pure: false,\n                    standalone: true,\n                }]\n        }], ctorParameters: function () { return [{ type: TranslocoService }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_SCOPE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LANG]\n                }] }, { type: i0.ChangeDetectorRef }]; } });\n\nconst decl = [TranslocoDirective, TranslocoPipe];\nclass TranslocoModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoModule, imports: [TranslocoDirective, TranslocoPipe], exports: [TranslocoDirective, TranslocoPipe] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoModule });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: decl,\n                    exports: decl,\n                }]\n        }] });\n\nfunction provideTransloco(options) {\n    const providers = [\n        provideTranslocoTranspiler(DefaultTranspiler),\n        provideTranslocoMissingHandler(DefaultHandler),\n        provideTranslocoInterceptor(DefaultInterceptor),\n        provideTranslocoFallbackStrategy(DefaultFallbackStrategy),\n    ];\n    if (options.config) {\n        providers.push(provideTranslocoConfig(options.config));\n    }\n    if (options.loader) {\n        providers.push(provideTranslocoLoader(options.loader));\n    }\n    return providers;\n}\nfunction provideTranslocoConfig(config) {\n    return makeEnvironmentProviders([\n        {\n            provide: TRANSLOCO_CONFIG,\n            useValue: translocoConfig(config),\n        },\n    ]);\n}\nfunction provideTranslocoLoader(loader) {\n    return makeEnvironmentProviders([\n        { provide: TRANSLOCO_LOADER, useClass: loader },\n    ]);\n}\nfunction provideTranslocoScope(scope) {\n    return {\n        provide: TRANSLOCO_SCOPE,\n        useValue: scope,\n        multi: true,\n    };\n}\nfunction provideTranslocoLoadingTpl(content) {\n    return {\n        provide: TRANSLOCO_LOADING_TEMPLATE,\n        useValue: content,\n    };\n}\nfunction provideTranslocoTranspiler(transpiler) {\n    return makeEnvironmentProviders([\n        {\n            provide: TRANSLOCO_TRANSPILER,\n            useClass: transpiler,\n            deps: [TRANSLOCO_CONFIG],\n        },\n    ]);\n}\nfunction provideTranslocoFallbackStrategy(strategy) {\n    return makeEnvironmentProviders([\n        {\n            provide: TRANSLOCO_FALLBACK_STRATEGY,\n            useClass: strategy,\n            deps: [TRANSLOCO_CONFIG],\n        },\n    ]);\n}\nfunction provideTranslocoMissingHandler(handler) {\n    return makeEnvironmentProviders([\n        {\n            provide: TRANSLOCO_MISSING_HANDLER,\n            useClass: handler,\n        },\n    ]);\n}\nfunction provideTranslocoInterceptor(interceptor) {\n    return makeEnvironmentProviders([\n        {\n            provide: TRANSLOCO_INTERCEPTOR,\n            useClass: interceptor,\n        },\n    ]);\n}\nfunction provideTranslocoLang(lang) {\n    return {\n        provide: TRANSLOCO_LANG,\n        useValue: lang,\n    };\n}\n\nconst TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\nclass TestingLoader {\n    langs;\n    constructor(langs) {\n        this.langs = langs;\n    }\n    getTranslation(lang) {\n        return of(this.langs[lang]);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TestingLoader, deps: [{ token: TRANSLOCO_TEST_LANGS }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TestingLoader });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TestingLoader, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_TEST_LANGS]\n                }] }]; } });\nfunction initTranslocoService(service, langs = {}, options) {\n    const preloadAllLangs = () => options.preloadLangs\n        ? Promise.all(Object.keys(langs).map((lang) => service.load(lang).toPromise()))\n        : Promise.resolve();\n    return preloadAllLangs;\n}\nclass TranslocoTestingModule {\n    static forRoot(options) {\n        return {\n            ngModule: TranslocoTestingModule,\n            providers: [\n                provideTransloco({\n                    loader: TestingLoader,\n                    config: {\n                        prodMode: true,\n                        missingHandler: { logMissingKey: false },\n                        ...options.translocoConfig,\n                    },\n                }),\n                {\n                    provide: TRANSLOCO_TEST_LANGS,\n                    useValue: options.langs,\n                },\n                {\n                    provide: TRANSLOCO_TEST_OPTIONS,\n                    useValue: options,\n                },\n                {\n                    provide: APP_INITIALIZER,\n                    useFactory: initTranslocoService,\n                    deps: [\n                        TranslocoService,\n                        TRANSLOCO_TEST_LANGS,\n                        TRANSLOCO_TEST_OPTIONS,\n                    ],\n                    multi: true,\n                },\n            ],\n        };\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoTestingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoTestingModule, exports: [TranslocoModule] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoTestingModule, imports: [TranslocoModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.7\", ngImport: i0, type: TranslocoTestingModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [TranslocoModule],\n                }]\n        }] });\n\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\nfunction getBrowserLang() {\n    let browserLang = getBrowserCultureLang();\n    if (!browserLang || !isBrowser()) {\n        return undefined;\n    }\n    if (browserLang.indexOf('-') !== -1) {\n        browserLang = browserLang.split('-')[0];\n    }\n    if (browserLang.indexOf('_') !== -1) {\n        browserLang = browserLang.split('_')[0];\n    }\n    return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\nfunction getBrowserCultureLang() {\n    if (!isBrowser()) {\n        return '';\n    }\n    const navigator = window.navigator;\n    return navigator.languages?.[0] ?? navigator.language;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DefaultFallbackStrategy, DefaultTranspiler, FunctionalTranspiler, TRANSLOCO_CONFIG, TRANSLOCO_FALLBACK_STRATEGY, TRANSLOCO_INTERCEPTOR, TRANSLOCO_LANG, TRANSLOCO_LOADER, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_MISSING_HANDLER, TRANSLOCO_SCOPE, TRANSLOCO_TRANSPILER, TestingLoader, TranslocoDirective, TranslocoModule, TranslocoPipe, TranslocoService, TranslocoTestingModule, coerceArray, defaultConfig, flatten, getBrowserCultureLang, getBrowserLang, getFunctionArgs, getLangFromScope, getPipeValue, getScopeFromLang, getValue, hasInlineLoader, isBrowser, isDefined, isEmpty, isFunction, isNil, isNumber, isObject, isScopeArray, isScopeObject, isString, provideTransloco, provideTranslocoConfig, provideTranslocoFallbackStrategy, provideTranslocoInterceptor, provideTranslocoLang, provideTranslocoLoader, provideTranslocoLoadingTpl, provideTranslocoMissingHandler, provideTranslocoScope, provideTranslocoTranspiler, setValue, size, toCamelCase, toNumber, translate, translateObject, translocoConfig, unflatten };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}